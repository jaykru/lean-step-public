{"type": "\u2200 {\u03b1 : Type u_1} {E : Type u_2} {\ud835\udd5c : Type u_3} [_inst_11 : normed_group E] [_inst_12 : normed_field \ud835\udd5c] {u : \u03b1 \u2192 E} {v : \u03b1 \u2192 \ud835\udd5c} {l : filter \u03b1} {y : \ud835\udd5c}, asymptotics.is_o u v l \u2192 filter.tendsto v l (nhds y) \u2192 filter.tendsto u l (nhds 0)"}
{"type": "\u2200 {\u03b1 : Type u} {s : set \u03b1} {t : set (set \u03b1)}, s \u2208 t \\ {\u2205} \u2194 s \u2208 t \u2227 s.nonempty"}
{"type": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {m0 : measurable_space \u03b1} [_inst_1 : measurable_space \u03b2] {\u03bc : measure_theory.measure \u03b1} {f : \u03b1 \u2192 \u03b2}, measurable f \u2192 filter.tendsto f \u03bc.ae (\u21d1(measure_theory.measure.map f) \u03bc).ae"}
{"type": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {s : set \u03b1} {t : set \u03b2} {f : \u03b1 \u2192 \u03b2}, set.maps_to f s t \u2192 filter.tendsto f (filter.principal s) (filter.principal t)"}
{"type": "\u2200 {x : \u211d}, x \u2260 0 \u2192 function.injective (\u03bb (y : nnreal), y ^ x)"}
{"type": "\u2200 {G : Type u_1} [_inst_3 : comm_group G] (K : subgroup G) {\u03b9 : Type u_2} {t : finset \u03b9} {f : \u03b9 \u2192 G}, (\u2200 (c : \u03b9), c \u2208 t \u2192 f c \u2208 K) \u2192 t.prod (\u03bb (c : \u03b9), f c) \u2208 K"}
{"type": "\u2200 {M : Type u_1} [_inst_1 : has_mul M] (c : con M) {x y z : M}, \u21d1c x y \u2192 \u21d1c y z \u2192 \u21d1c x z"}
{"type": "\u2200 {G : Type u_3} [_inst_3 : group G], \u22a4\u207b\u00b9 = \u22a4"}
{"type": "\u2200 {\u03b9 : Type u_1} {\u03b1 : \u03b9 \u2192 Type u_2} {s : set \u03b9} {t\u2081 t\u2082 : \u03a0 (i : \u03b9), set (\u03b1 i)}, (\u2200 (i : \u03b9), i \u2208 s \u2192 t\u2081 i \u2286 t\u2082 i) \u2192 s.pi t\u2081 \u2286 s.pi t\u2082"}
{"type": "\u2200 {\u03b1 : Type u_1} {l : filter \u03b1} {f : \u03b1 \u2192 \u211d}, filter.tendsto (\u03bb (x : \u03b1), real.exp (f x)) l filter.at_top \u2194 filter.tendsto f l filter.at_top"}
{"type": "\u2200 {R : Type u_1} {\u0393\u2080 : Type u_2} [_inst_2 : ring R] [_inst_3 : linear_ordered_comm_monoid_with_zero \u0393\u2080] (v : valuation R \u0393\u2080) {x y : R} {g : \u0393\u2080}, \u21d1v x \u2264 g \u2192 \u21d1v y \u2264 g \u2192 \u21d1v (x + y) \u2264 g"}
{"type": "\u2200 {n : \u2115} (a b : fin n), a = b \u2194 \u2191a = \u2191b"}
{"type": "\u2200 (a : pos_num), 1.sub' a = a.pred'.to_znum_neg"}
{"type": "\u2200 {\u03b1 : Type u_1} [_inst_1 : linear_ordered_field \u03b1] {\u03b2 : Type u_2} [_inst_2 : ring \u03b2] {abv : \u03b2 \u2192 \u03b1} [_inst_3 : is_absolute_value abv] (f g : cau_seq \u03b2 abv) (i : \u2115), \u21d1(f - g) i = \u21d1f i - \u21d1g i"}
{"type": "\u2200 {n : \u2115} (x y : composition n), x.blocks = y.blocks \u2192 x = y"}
{"type": "\u2200 {R : Type u_2} {V : Type u_3} {W : Type u_4} {P : Type u_6} [_inst_1 : normed_group V] [_inst_2 : metric_space P] [_inst_3 : normed_add_torsor V P] [_inst_4 : normed_group W] [_inst_10 : normed_field R] [_inst_11 : normed_space R V] [_inst_12 : normed_space R W] (f g : P \u2192A[R] W), (f + g).cont_linear = f.cont_linear + g.cont_linear"}
{"type": "\u2200 (n : \u2115), (finset.nat.antidiagonal n).card = n + 1"}
{"type": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {F : Type u_4} [_inst_6 : normed_group F] [_inst_7 : normed_space \ud835\udd5c F] {H : Type u_5} [_inst_8 : topological_space H] {G : Type u_7} [_inst_10 : topological_space G] {I : model_with_corners \ud835\udd5c E H} {J : model_with_corners \ud835\udd5c F G} {M : Type u_8} [_inst_11 : topological_space M] [_inst_12 : charted_space H M] {N : Type u_10} [_inst_15 : topological_space N] [_inst_16 : charted_space G N] {n : with_top \u2115} (h : diffeomorph I J M N n), h.symm.to_equiv = h.to_equiv.symm"}
{"type": "\u2200 {G : Type u} [_inst_1 : group G] {a b c : G}, a / (b / c) = a * c / b"}
{"type": "has_sup.sup = or"}
{"type": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : pseudo_emetric_space \u03b1] [_inst_2 : pseudo_emetric_space \u03b2] {K : nnreal} {f : \u03b1 \u2192 \u03b2}, lipschitz_with K f \u2192 continuous f"}
{"type": "\u2200 {\u03b1 : Type u_1} [_inst_1 : linear_ordered_field \u03b1] {a b : \u03b1}, a < 0 \u2192 b < 0 \u2192 (a < b\u207b\u00b9 \u2194 b < a\u207b\u00b9)"}
{"type": "\u2200 {P : Type u_1} [_inst_1 : semilattice_sup P] [_inst_2 : order.ideal.ideal_Inter_nonempty P] {I : order.ideal P} {s : set (order.ideal P)}, I \u2208 s \u2192 has_Inf.Inf s \u2264 I"}
{"type": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {E' : Type u_3} [_inst_4 : normed_group E'] [_inst_5 : normed_space \ud835\udd5c E'] {f : E \u2192 E'} {x : E} {f' : tangent_space (model_with_corners_self \ud835\udd5c E) x \u2192L[\ud835\udd5c] tangent_space (model_with_corners_self \ud835\udd5c E') (f x)}, has_fderiv_at f f' x \u2192 has_mfderiv_at (model_with_corners_self \ud835\udd5c E) (model_with_corners_self \ud835\udd5c E') f x f'"}
{"type": "\u2200 {\u03b1 : Type u_2} {_inst_1 : preorder \u03b1} (x y : succ_order \u03b1), x = y \u2194 succ_order.succ = succ_order.succ"}
{"type": "\u2200 {R : Type u} {S : Type v} [_inst_1 : semiring R] {p : polynomial R} [_inst_2 : semiring S] {q : polynomial S}, p.degree \u2264 q.degree \u2192 p.nat_degree \u2264 q.nat_degree"}
{"type": "\u2200 {S : Type u_1} [_inst_1 : add_semigroup S] {b c : S}, add_commute b c \u2192 \u2200 (a : S), a + b + c = a + c + b"}
{"type": "\u2200 {\u03b1 : Type} {F : parser \u03b1 \u2192 parser \u03b1}, (\u2200 (p : parser \u03b1), p.err_static \u2192 (F p).err_static) \u2192 \u2200 (max_depth : \u2115), (parser.fix_core F max_depth).err_static"}
{"type": "\u2200 {R\u2081 : Type u_1} [_inst_1 : semiring R\u2081] {M\u2081 : Type u_4} [_inst_4 : topological_space M\u2081] [_inst_5 : add_comm_monoid M\u2081] [_inst_14 : module R\u2081 M\u2081] (p : submodule R\u2081 M\u2081) (x : \u21a5p), \u21d1(continuous_linear_map.subtype_val p) x = \u2191x"}
{"type": "\u2200 {G : Type u_1} [_inst_3 : group G] (S : set G) (x : G), x \u2208 submonoid.closure S\u207b\u00b9 \u2194 x\u207b\u00b9 \u2208 submonoid.closure S"}
{"type": "\u2200 {\u03b1 : Type u} (s : wseq \u03b1), s.think.destruct = s.destruct.think"}
{"type": "\u2200 {M : Type u_1} {\u03b1 : Type u_4} {\u03b2 : Type u_5} [_inst_1 : has_vadd M \u03b1] [_inst_2 : has_vadd M \u03b2] (a : M) (b : \u03b1) (c : \u03b2), a +\u1d65 (b, c) = (a +\u1d65 b, a +\u1d65 c)"}
{"type": "\u2200 {ds\u2081 ds\u2082 : list \u2115} {\u03b1 : Type} [_inst_1 : ring \u03b1] (x : holor \u03b1 ds\u2081), x.mul 0 = 0"}
{"type": "\u2200 {\u03c4 : Type u_1} [_inst_1 : add_monoid \u03c4] [_inst_2 : topological_space \u03c4] [_inst_3 : has_continuous_add \u03c4] {\u03b1 : Type u_2} [_inst_4 : topological_space \u03b1] (\u03d5 : flow \u03c4 \u03b1), \u21d1\u03d5 0 = id"}
{"type": "\u2200 {\u03b1 : Type u_1} (a : \u03b1), (pmf.pure a).support = {a}"}
{"type": "\u2200 {\u03b1 : Type u} [_inst_1 : linear_order \u03b1] {x y : \u03b1}, x < y \u2194 \u00acy \u2264 x"}
{"type": "\u2200 {\u03c4 : Type u_1} {\u03b1 : Type u_2} {\u03b2 : Type u_3} [_inst_1 : topological_space \u03b2] (s : set \u03b1) {\u03b1' : Type u_4} (\u03d5 : \u03c4 \u2192 \u03b1' \u2192 \u03b2) (f : filter \u03c4) (g : \u03b1 \u2192 \u03b1'), omega_limit f \u03d5 (g '' s) = omega_limit f (\u03bb (t : \u03c4) (x : \u03b1), \u03d5 t (g x)) s"}
{"type": "\u2200 {R : Type u_1} {R\u2082 : Type u_2} {E : Type u_5} {E\u2082 : Type u_6} [_inst_1 : semiring R] [_inst_2 : semiring R\u2082] {\u03c3\u2081\u2082 : R \u2192+* R\u2082} {\u03c3\u2082\u2081 : R\u2082 \u2192+* R} [_inst_5 : ring_hom_inv_pair \u03c3\u2081\u2082 \u03c3\u2082\u2081] [_inst_6 : ring_hom_inv_pair \u03c3\u2082\u2081 \u03c3\u2081\u2082] [_inst_25 : semi_normed_group E] [_inst_26 : semi_normed_group E\u2082] [_inst_29 : module R E] [_inst_30 : module R\u2082 E\u2082] (e : E \u2243\u209b\u2097\u1d62[\u03c3\u2081\u2082] E\u2082), antilipschitz_with 1 \u21d1e"}
{"type": "\u2200 {\u03b1 : Type u_1} [_inst_1 : measurable_space \u03b1] {s\u2081 s\u2082 s' : set (set \u03b1)} {\u03bc : measure_theory.measure \u03b1}, probability_theory.indep_sets (s\u2081 \u222a s\u2082) s' \u03bc \u2194 probability_theory.indep_sets s\u2081 s' \u03bc \u2227 probability_theory.indep_sets s\u2082 s' \u03bc"}
{"type": "\u2200 {K : Type u} {V : Type v} [_inst_1 : field K] [_inst_2 : add_comm_group V] [_inst_3 : module K V] {s : submodule K V}, 0 < module.rank K \u21a5s \u2192 (\u2203 (b : V), b \u2208 s \u2227 b \u2260 0)"}
{"type": "\u2200 {K : Type u} {V : Type v} [_inst_1 : division_ring K] [_inst_2 : add_comm_group V] [_inst_3 : module K V] {n : \u2115}, module.rank K V = \u2191n \u2192 finite_dimensional.finrank K V = n"}
{"type": "\u2200 {G : Type u} [_inst_1 : add_group G] {B : add_group_filter_basis G} {U : set G}, U \u2208 B \u2192 (\u2203 (V : set G) (H : V \u2208 B), V + V \u2286 U)"}
{"type": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {D : Type u\u2082} [_inst_2 : category_theory.category D] (e : C \u224c D) {X Y : C} (f f' : X \u27f6 e.inverse.obj (e.functor.obj Y)), f \u226b e.unit_inv.app Y = f' \u226b e.unit_inv.app Y \u2194 f = f'"}
{"type": "\u2200 {\u03b1 : Type u} [_inst_1 : pseudo_metric_space \u03b1] {x : \u03b1} {s : set \u03b1}, s \u2208 nhds x \u2194 \u2203 (\u03b5 : \u211d) (H : \u03b5 > 0), metric.ball x \u03b5 \u2286 s"}
{"type": "\u2200 {\u03b1 : Type u_1} {M : Type u_5} [_inst_1 : has_zero M] {s : set \u03b1} {f : \u03b1 \u2192\u2080 M}, \u2191(f.support) \u2286 s \u2194 \u2200 (a : \u03b1), a \u2209 s \u2192 \u21d1f a = 0"}
{"type": "\u2200 {a b : ennreal}, b \u2260 \u22a4 \u2192 a < b \u2192 a.to_real < b.to_real"}
{"type": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} (e : local_equiv \u03b1 \u03b2) (s : set \u03b1), (e.restr s).source = e.source \u2229 s"}
{"type": "\u2200 {R : Type u} [_inst_1 : semiring R], polynomial.map_ring_hom (ring_hom.id R) = ring_hom.id (polynomial R)"}
{"type": "\u2200 {\u03b1 : Type u} {s : set \u03b1} (h : s.finite), h.to_finset.nonempty \u2194 s.nonempty"}
{"type": "\u2200 {E : Type u_3} [_inst_1 : semi_normed_group E] (x : E), (isometric.add_left x).symm = isometric.add_left (-x)"}
{"type": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {l l' : filter \u03b1} {f g : \u03b1 \u2192 \u03b2}, f =\u1da0[l] g \u2192 l' \u2264 l \u2192 f =\u1da0[l'] g"}
{"type": "\u2200 {R : Type u} [_inst_1 : ring R] {\u03b9 : Sort u_1} (s : \u03b9 \u2192 set R), subring.closure (\u22c3 (i : \u03b9), s i) = \u2a06 (i : \u03b9), subring.closure (s i)"}
{"type": "\u2200 {K : Type u} {L : Type v} [_inst_1 : field K] [_inst_2 : field L] (s t : subfield L) (f : K \u2192+* L), subfield.comap f (s \u2293 t) = subfield.comap f s \u2293 subfield.comap f t"}
{"type": "\u2200 {\u03b1 : Type u_3} {\u03b2 : Type u_4} [_inst_1 : ordered_add_comm_monoid \u03b2] {l : filter \u03b1} {f g : \u03b1 \u2192 \u03b2}, (\u2200\u1da0 (x : \u03b1) in l, 0 \u2264 f x) \u2192 filter.tendsto g l filter.at_top \u2192 filter.tendsto (\u03bb (x : \u03b1), f x + g x) l filter.at_top"}
{"type": "\u2200 {\u03b1 : Type u_1} {f : \u03b1 \u2192 \u03b1} {x : \u03b1} {n : \u2115}, n \u2260 0 \u2192 function.minimal_period f^[n] x = function.minimal_period f x / (function.minimal_period f x).gcd n"}
{"type": "0 \u2208 real.cos '' set.Icc 1 2"}
{"type": "\u2200 {M : Type u_1} [_inst_1 : add_monoid M] {a b : M}, add_commute a b \u2192 \u2200 (n : \u2115), add_commute (n \u2022 a) b"}
{"type": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {f : \u03b1 \u2192 \u03b2} {c x : \u03b1} [_inst_1 : add_comm_group \u03b1], function.periodic f c \u2192 \u2200 (n : \u2124), f (n \u2022 c - x) = f (-x)"}
{"type": "\u2200 (R : Type u) {S : Type v} {A : Type w} {B : Type u\u2081} [_inst_1 : comm_semiring R] [_inst_2 : comm_semiring S] [_inst_3 : semiring A] [_inst_4 : semiring B] [_inst_5 : algebra R S] [_inst_6 : algebra S A] [_inst_7 : algebra S B] [_inst_8 : algebra R A] [_inst_9 : algebra R B] [_inst_10 : is_scalar_tower R S A] [_inst_11 : is_scalar_tower R S B] (f : A \u2243\u2090[S] B) (x : A), \u21d1(alg_equiv.restrict_scalars R f) x = \u21d1f x"}
{"type": "\u2200 {K : Type u} [_inst_1 : linear_ordered_field K] {a : K}, a \u2260 0 \u2192 \u2200 (n : \u2124), 0 < a ^ bit0 n"}
{"type": "\u2200 {\u03b1 : Type u_1} [_inst_1 : measurable_space \u03b1] {M : Type u_3} [_inst_3 : add_comm_monoid M] [_inst_4 : topological_space M] (v : measure_theory.vector_measure \u03b1 M) {i : set \u03b1}, measurable_set i \u2192 \u2200 {j : set \u03b1}, measurable_set j \u2192 j \u2286 i \u2192 \u21d1(v.restrict i) j = \u21d1v j"}
{"type": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : complete_lattice \u03b1] {f : \u03b2 \u2192 \u03b1} {a b : \u03b2}, (\u2a06 (x : \u03b2) (H : x \u2208 {a, b}), f x) = f a \u2294 f b"}
{"type": "\u2200 {m : Type u_2} {n : Type u_3} {\u03b1 : Type v} [_inst_1 : add_comm_monoid \u03b1] [_inst_2 : star_add_monoid \u03b1] (s : multiset (matrix m n \u03b1)), s.sum.conj_transpose = (multiset.map matrix.conj_transpose s).sum"}
{"type": "\u2200 {R : Type u} {A : Type v} [_inst_1 : comm_semiring R] [_inst_2 : semiring A] [_inst_3 : algebra R A] (S : subalgebra R A) {x : A}, x \u2208 S \u2192 \u2200 (r : R), r \u2022 x \u2208 S"}
{"type": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_3} {E : Type u_6} [_inst_1 : measurable_space \u03b1] [_inst_3 : measurable_space \u03b2] {\u03bc : measure_theory.measure \u03b1} {\u03bd : measure_theory.measure \u03b2} [_inst_6 : normed_group E] [_inst_7 : measurable_space E] [_inst_8 : measure_theory.sigma_finite \u03bd] [_inst_9 : topological_space.second_countable_topology E] [_inst_10 : normed_space \u211d E] [_inst_11 : complete_space E] [_inst_12 : borel_space E] [_inst_13 : measure_theory.sigma_finite \u03bc] \u2983f g : \u03b1 \u00d7 \u03b2 \u2192 E\u2984, measure_theory.integrable f (\u03bc.prod \u03bd) \u2192 measure_theory.integrable g (\u03bc.prod \u03bd) \u2192 \u222b (x : \u03b1), \u222b (y : \u03b2), f (x, y) + g (x, y) \u2202\u03bd \u2202\u03bc = \u222b (x : \u03b1), \u222b (y : \u03b2), f (x, y) \u2202\u03bd \u2202\u03bc + \u222b (x : \u03b1), \u222b (y : \u03b2), g (x, y) \u2202\u03bd \u2202\u03bc"}
{"type": "\u2200 {R : Type u_4} [_inst_1 : linear_ordered_semiring R] {a : R}, 0 \u2264 a \u2192 \u2200 {n : \u2115}, n \u2260 0 \u2192 (1 \u2264 a ^ n \u2194 1 \u2264 a)"}
{"type": "\u2200 {\u03b1 : Type u_1} {M : Type u_5} [_inst_1 : has_zero M] (f : \u03b1 \u2192 M) (s : finset \u03b1) (h : \u2200 (a : \u03b1), a \u2208 s \u2194 f a \u2260 0), \u21d1{support := s, to_fun := f, mem_support_to_fun := h} = f"}
{"type": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : preorder \u03b1] [_inst_2 : preorder \u03b2] {f : \u03b1 \u2192 \u03b2}, monotone f \u2192 \u2200 {s : set \u03b2} (hs : \u2200 (x : \u03b1), f x \u2208 s), monotone (set.cod_restrict f s hs)"}
{"type": "\u2200 {M : Type u_1} {N : Type u_2} [_inst_1 : add_zero_class M] [_inst_2 : add_zero_class N] (f : M \u2192+ N), \u2191(f.mker) = \u21d1f \u207b\u00b9' {0}"}
{"type": "\u2200 {\u03b1 : Type u_1} {m : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} {t : measure_theory.signed_measure \u03b1} {f : \u03b1 \u2192 \u211d}, measurable f \u2192 measure_theory.vector_measure.mutually_singular t \u03bc.to_ennreal_vector_measure \u2192 (t.to_jordan_decomposition.pos_part + \u03bc.with_density (\u03bb (x : \u03b1), ennreal.of_real (f x))).mutually_singular (t.to_jordan_decomposition.neg_part + \u03bc.with_density (\u03bb (x : \u03b1), ennreal.of_real (-f x)))"}
{"type": "\u2200 {\u03b1 : Type u} {s : set \u03b1}, s.subsingleton \u2192 s.finite"}
{"type": "\u2200 {\u03b1 : Type u} [_inst_1 : add_comm_group \u03b1] [_inst_2 : has_lt \u03b1] [_inst_3 : covariant_class \u03b1 \u03b1 has_add.add has_lt.lt] {a b c : \u03b1}, a + b < c \u2192 b < c - a"}
{"type": "\u2200 {X Y : Type u} [_inst_1 : semigroup X] [_inst_2 : semigroup Y] (e : X \u2243* Y), e.to_Semigroup_iso.inv = e.symm.to_mul_hom"}
{"type": "\u2200 {\u03b2 : Type u} {\u03b1 : Type v} {\u03b3 : Type w} [_inst_1 : comm_semiring \u03b2] [_inst_2 : comm_semiring \u03b3] (g : \u03b2 \u2192+* \u03b3) (f : \u03b1 \u2192 \u03b2) (s : finset \u03b1), \u21d1g (s.prod (\u03bb (x : \u03b1), f x)) = s.prod (\u03bb (x : \u03b1), \u21d1g (f x))"}
{"type": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : pseudo_emetric_space \u03b1] [_inst_2 : pseudo_emetric_space \u03b2] (h : \u03b1 \u2243\u1d62 \u03b2), \u21d1h \u2218 \u21d1(h.symm) = id"}
{"type": "\u2200 (a b c : bool), bxor (bxor a b) c = bxor a (bxor b c)"}
{"type": "\u2200 {\u03b1 : Type u} [_inst_1 : decidable_eq \u03b1] (l\u2081 l\u2082 : list \u03b1) (a : \u03b1), (l\u2081.diff l\u2082).erase a = (l\u2081.erase a).diff l\u2082"}
{"type": "\u2200 {\u03b1 : Type u_1} [_inst_1 : preorder \u03b1] {t\u2081 t\u2082 : ordnode \u03b1} {x : \u03b1} {o\u2081 : with_bot \u03b1} {o\u2082 : with_top \u03b1}, t\u2081.bounded o\u2081 \u2191x \u2192 ordnode.valid' \u2191x t\u2082 o\u2082 \u2192 ordnode.valid' o\u2081 t\u2082 o\u2082"}
{"type": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {\u03b3 : Type u_3} [_inst_1 : topological_space \u03b1] [_inst_2 : topological_space \u03b2] [_inst_3 : topological_space \u03b3] {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}, inducing g \u2192 \u2200 {s : set \u03b1} {x : \u03b1}, continuous_within_at f s x \u2194 continuous_within_at (g \u2218 f) s x"}
{"type": "\u2200 {\u03b1 : Type u_1} [_inst_1 : ordered_add_comm_group \u03b1] {a b c d : \u03b1}, a + b \u2208 set.Ioo c d \u2194 b \u2208 set.Ioo (c - a) (d - a)"}
{"type": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : preorder \u03b1] [_inst_2 : semilattice_sup \u03b2] (f g : \u03b1 \u2192o \u03b2) (a : \u03b1), \u21d1(f \u2294 g) a = \u21d1f a \u2294 \u21d1g a"}
{"type": "\u2200 {\u03b1 : Type u_1} [_inst_1 : has_add \u03b1] {s : set \u03b1} {x : \u03b1} (a : \u03b1), x \u2208 s \u2192 a + x \u2208 left_add_coset a s"}
{"type": "\u2200 {\u03b1 : Type u_1} {f : equiv.perm \u03b1} (l : list (equiv.perm \u03b1)), (\u2200 (g : equiv.perm \u03b1), g \u2208 l \u2192 f.disjoint g) \u2192 f.disjoint l.prod"}
{"type": "\u2200 {\u03b1 : Type u_1} {M : Type u_5} [_inst_1 : has_zero M] [_inst_2 : unique \u03b1] {f g : \u03b1 \u2192\u2080 M}, f = g \u2194 \u21d1f (inhabited.default \u03b1) = \u21d1g (inhabited.default \u03b1)"}
{"type": "\u2200 {\u03b1 : Type u} {\u03b2 : \u03b1 \u2192 Type v} [_inst_1 : decidable_eq \u03b1] (a : \u03b1) (b : \u03b2 a) (xs : list (sigma \u03b2)), (\u27e8a, b\u27e9 :: xs).to_alist = alist.insert a b xs.to_alist"}
{"type": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {M : Type w} [_inst_1 : linear_ordered_cancel_add_comm_monoid M] [_inst_2 : decidable_eq \u03b2] {s : finset \u03b1} {t : finset \u03b2} {f : \u03b1 \u2192 \u03b2} {w : \u03b1 \u2192 M} {b : M}, (\u2200 (y : \u03b2), y \u2209 t \u2192 0 \u2264 (finset.filter (\u03bb (x : \u03b1), f x = y) s).sum (\u03bb (x : \u03b1), w x)) \u2192 t.nonempty \u2192 s.sum (\u03bb (x : \u03b1), w x) \u2264 t.card \u2022 b \u2192 (\u2203 (y : \u03b2) (H : y \u2208 t), (finset.filter (\u03bb (x : \u03b1), f x = y) s).sum (\u03bb (x : \u03b1), w x) \u2264 b)"}
{"type": "\u2200 {\u03b1 : Type u} (a : \u03b1) (s : stream \u03b1), a \u2208 a::s"}
{"type": "\u2200 {\u03b1 : Type u_1} [_inst_1 : topological_space \u03b1] {s : set \u03b1} {\u03b9 : Sort u_3} {\u03b4 : Type u_4} [_inst_3 : complete_linear_order \u03b4] {f : \u03b9 \u2192 \u03b1 \u2192 \u03b4}, (\u2200 (i : \u03b9), upper_semicontinuous_on (f i) s) \u2192 upper_semicontinuous_on (\u03bb (x' : \u03b1), \u2a05 (i : \u03b9), f i x') s"}
{"type": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {X : C} (P : category_theory.subobject X) (h : P.factors P.arrow), P.factor_thru P.arrow h = \ud835\udfd9 \u2191P"}
{"type": "\u2200 {\u03b1 : Type u_1} [_inst_1 : linear_ordered_field \u03b1], archimedean \u03b1 \u2194 \u2200 (x : \u03b1), \u2203 (q : \u211a), x \u2264 \u2191q"}
{"type": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] [_inst_2 : category_theory.preadditive C] {D : Type u_1} [_inst_3 : category_theory.category D] [_inst_4 : category_theory.preadditive D] (F : C \u2964 D) [_inst_5 : F.additive] (M : category_theory.Mat_ C) (a b : M.\u03b9), (F.map_Mat_.obj M).D a b = M.D a b"}
{"type": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {s : computation \u03b1} {f : \u03b1 \u2192 computation \u03b2} {b : \u03b2}, b \u2208 s.bind f \u2192 (\u2203 (a : \u03b1) (H : a \u2208 s), b \u2208 f a)"}
{"type": "\u2200 {m n : \u2115}, multiset.range m \u2286 multiset.range n \u2194 m \u2264 n"}
{"type": "\u2200 {\u03b1 : Type u_1} {m : measurable_space \u03b1} \u2983\u03bc : measure_theory.measure \u03b1\u2984 {s t : set \u03b1} {f : \u03b1 \u2192 ennreal}, s \u2264\u1d50[\u03bc] t \u2192 \u222b\u207b (x : \u03b1) in s, f x \u2202\u03bc \u2264 \u222b\u207b (x : \u03b1) in t, f x \u2202\u03bc"}
{"type": "\u2200 {J : Type u\u2081} [_inst_1 : category_theory.category J] {C : Type u\u2083} [_inst_3 : category_theory.category C] (F : J \u2964 C) (c : \u03a3 (X : C\u1d52\u1d56), F.cones.obj X), ((category_theory.limits.cone.equiv F).inv c).\u03c0 = c.snd"}
{"type": "\u2200 {\u03b1 : Type u_1} (f : \u2115 \u2192 \u03b1 \u2192 ennreal) (x : \u03b1), monotone (\u03bb (n : \u2115), \u2a06 (k : \u2115) (hk : k \u2264 n), f k x)"}
{"type": "\u2200 {M : Type u_5} {N : Type u_6} [_inst_1 : add_zero_class M] [_inst_2 : add_zero_class N] (p : M \u00d7 N), (p.fst, 0) + (0, p.snd) = p"}
{"type": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : topological_space \u03b1] [_inst_2 : topological_space \u03b2] (x : \u03b1 \u00d7 \u03b2), filter.map prod.snd (nhds x) = nhds x.snd"}
{"type": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} [_inst_1 : preorder \u03b2] [_inst_2 : preorder \u03b3] {f : \u03b1 \u2192 \u03b2} {l : filter \u03b1} {a : \u03b1}, is_max_filter f l a \u2192 \u2200 {g : \u03b2 \u2192 \u03b3}, monotone g \u2192 is_max_filter (g \u2218 f) l a"}
{"type": "\u2200 {S : Type u_1} [_inst_1 : ordered_semiring S] {R : Type u_2} [_inst_2 : semiring R] (abv : R \u2192 S) [_inst_3 : is_absolute_value abv] (\u1fb0 : R), (is_absolute_value.to_absolute_value abv).to_mul_hom.to_fun \u1fb0 = abv \u1fb0"}
{"type": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {x : E} {f : E \u2192 E}, differentiable_at \ud835\udd5c f x \u2192 f x = x \u2192 \u2200 (n : \u2115), differentiable_at \ud835\udd5c f^[n] x"}
{"type": "\u2200 {\u03b1 : Type u_1} {n : Type u_4} [_inst_1 : semiring \u03b1] [_inst_2 : star_ring \u03b1] {A : matrix n n \u03b1}, A.conj_transpose.is_diag \u2194 A.is_diag"}
{"type": "\u2200 {G\u2080 : Type u_1} [_inst_1 : group_with_zero G\u2080] {a : G\u2080} (n : \u2115), (1 / a) ^ n = 1 / a ^ n"}
{"type": "\u2200 (a b c : nnreal), c \u2260 0 \u2192 b + a / c = (b * c + a) / c"}
{"type": "\u2200 {\u03b1 : Type u_1} [_inst_1 : decidable_eq \u03b1] (s : finset \u03b1), finset.Iio s = s.ssubsets"}
{"type": "\u2200 {\u03b1 : Type u_1} [_inst_1 : semi_normed_ring \u03b1] [_inst_2 : norm_one_class \u03b1] (l : list \u03b1), \u2225l.prod\u2225 \u2264 (list.map has_norm.norm l).prod"}
{"type": "\u2200 {R : Type u_1} {M : Type u_2} [_inst_1 : ordered_semiring R] [_inst_2 : ordered_add_comm_monoid M] [_inst_3 : smul_with_zero R M] [_inst_4 : ordered_smul R M] {c : R}, 0 \u2264 c \u2192 monotone (has_scalar.smul c)"}
{"type": "\u2200 (x : \u211d), has_strict_deriv_at real.exp (real.exp x) x"}
{"type": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {s t : set \u03b1} {f : \u03b2 \u2192 \u03b1}, function.surjective f \u2192 (f \u207b\u00b9' s = f \u207b\u00b9' t \u2194 s = t)"}
{"type": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : normed_field \ud835\udd5c], filter.tendsto (\u03bb (x : \ud835\udd5c), \u2225x\u207b\u00b9\u2225) (nhds_within 0 {0}\u1d9c) filter.at_top"}
{"type": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] {V W X Y : C} [_inst_2 : category_theory.limits.has_binary_coproduct X Y] (f : V \u27f6 W) (g : X \u27f6 V) (h : Y \u27f6 V) {X' : C} (f' : W \u27f6 X'), category_theory.limits.coprod.desc g h \u226b f \u226b f' = category_theory.limits.coprod.desc (g \u226b f) (h \u226b f) \u226b f'"}
{"type": "\u2200 {\u03b1 : Type u_1} {m0 : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} [_inst_3 : measure_theory.has_no_atoms \u03bc] [_inst_4 : partial_order \u03b1] {a b : \u03b1}, set.Ioc a b =\u1d50[\u03bc] set.Icc a b"}
{"type": "\u2200 {f : \u211d \u2192 \u211d} {f' x : \u211d} {s : set \u211d}, has_deriv_within_at f f' s x \u2192 has_deriv_within_at (\u03bb (x : \u211d), real.cosh (f x)) (real.sinh (f x) * f') s x"}
{"type": "\u2200 {\u03b1 : Type u} [_inst_1 : linear_ordered_semiring \u03b1] {a : \u03b1}, 0 < a \u2192 strict_mono (\u03bb (x : \u03b1), a * x)"}
{"type": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] [_inst_2 : category_theory.monoidal_category C] (X Y : category_theory.center C), (X.braiding Y).inv.f = (X.snd.\u03b2 Y.fst).inv"}
{"type": "\u2200 {\u03b1 : Type u} [_inst_1 : linear_order \u03b1] {a\u2081 a\u2082 b\u2081 b\u2082 : \u03b1}, a\u2081 < b\u2081 \u2192 (set.Ioc a\u2081 b\u2081 \u2286 set.Ioc a\u2082 b\u2082 \u2194 b\u2081 \u2264 b\u2082 \u2227 a\u2082 \u2264 a\u2081)"}
{"type": "\u2200 {R : Type u_1} [_inst_1 : comm_semiring R] (M : Type u_4) {N : Type u_5} [_inst_4 : add_comm_monoid M] [_inst_5 : add_comm_monoid N] [_inst_9 : module R M] [_inst_10 : module R N] (f g : module.End R N), linear_map.ltensor M (f * g) = linear_map.ltensor M f * linear_map.ltensor M g"}
{"type": "\u2200 {\u03b1 : Type u} {x a : \u03b1} {s : set \u03b1}, x \u2208 has_insert.insert a s \u2192 x \u2260 a \u2192 x \u2208 s"}
{"type": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} [_inst_1 : topological_space \u03b1] [_inst_2 : preorder \u03b2] [_inst_3 : preorder \u03b3] {f : \u03b1 \u2192 \u03b2} {a : \u03b1}, is_local_max f a \u2192 \u2200 {g : \u03b2 \u2192 \u03b3}, monotone g \u2192 is_local_max (g \u2218 f) a"}
{"type": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {F : Type u_3} [_inst_4 : normed_group F] [_inst_5 : normed_space \ud835\udd5c F] {G : Type u_4} [_inst_6 : normed_group G] [_inst_7 : normed_space \ud835\udd5c G] {f\u2081 : E \u2192 F} {f\u2081' : E \u2192L[\ud835\udd5c] F} {x : E} {f\u2082 : E \u2192 G} {f\u2082' : E \u2192L[\ud835\udd5c] G}, has_fderiv_at f\u2081 f\u2081' x \u2192 has_fderiv_at f\u2082 f\u2082' x \u2192 has_fderiv_at (\u03bb (x : E), (f\u2081 x, f\u2082 x)) (f\u2081'.prod f\u2082') x"}
{"type": "\u2200 {\u03b2 : Type u_2} {\u03b9 : Sort u_4} (f : \u03b9 \u2192 set \u03b2), \u22c2\u2080 set.range f = \u22c2 (x : \u03b9), f x"}
{"type": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : uniform_space \u03b1] [_inst_2 : uniform_space \u03b2] {f : \u03b1 \u2192 \u03b2}, uniform_inducing f \u2192 dense_range f \u2192 dense_inducing f"}
{"type": "\u2200 {K : Type u} {V : Type v} [_inst_1 : field K] [_inst_2 : add_comm_group V] [_inst_3 : module K V] (s : finset V), finite_dimensional.finrank K \u21a5(submodule.span K \u2191s) \u2264 s.card"}
{"type": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : complete_lattice \u03b1] [_inst_2 : complete_lattice \u03b2] (f : \u03b2 \u2192o \u03b1) (g : \u03b1 \u2192o \u03b2), \u21d1f (\u21d1order_hom.gfp (g.comp f)) = \u21d1order_hom.gfp (f.comp g)"}
{"type": "\u2200 {\u03b1 : Type u_1} [_inst_1 : linear_ordered_field \u03b1] {a b c : \u03b1}, 0 \u2264 b \u2192 0 \u2264 c \u2192 a \u2264 c * b \u2192 a / b \u2264 c"}
{"type": "\u2200 {T : Type u\u2081} [_inst_1 : category_theory.category T] {X : T} {A B : category_theory.under X} (f : A \u27f6 B), A.hom \u226b f.right = B.hom"}
{"type": "\u2200 {\u03b1 : Type u_1} [_inst_1 : decidable_eq \u03b1] (a : \u03b1) (s : finset \u03b1), (has_insert.insert a s).nonempty"}
{"type": "\u2200 {R : Type u_1} [_inst_1 : ring R] [_inst_2 : star_ring R], \u21911 = 1"}
{"type": "\u2200 {\u03b1 : Type u_1} [_inst_1 : linear_ordered_field \u03b1] {\u03b2 : Type u_2} [_inst_2 : ring \u03b2] {abv : \u03b2 \u2192 \u03b1} [_inst_3 : is_absolute_value abv] {f : cau_seq \u03b2 abv}, \u00acf \u2248 0 \u2192 \u00acf.lim_zero"}
{"type": "\u2200 {R : Type u_1} {S : Type u_2} [_inst_1 : non_assoc_semiring R] [_inst_2 : non_assoc_semiring S] (f : R \u2192+* S) (hf : function.bijective \u21d1f), \u21d1(ring_equiv.of_bijective f hf) = \u21d1f"}
{"type": "\u2200 {I : Type u\u2081} {J : Type u\u2082} (e : I \u2243 J), (category_theory.discrete.equivalence e).counit_iso = category_theory.discrete.nat_iso (\u03bb (j : category_theory.discrete J), category_theory.eq_to_iso _)"}
{"type": "\u2200 {\u03b1 : Type u_1} [_inst_1 : mul_one_class \u03b1] [_inst_2 : has_le \u03b1] [_inst_3 : covariant_class \u03b1 \u03b1 (function.swap has_mul.mul) has_le.le] [_inst_4 : contravariant_class \u03b1 \u03b1 (function.swap has_mul.mul) has_le.le] {a b : \u03b1}, a * b \u2264 b \u2194 a \u2264 1"}
{"type": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {\u03b9 : Type u_4} [_inst_1 : uniform_space \u03b2] {F : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {s s' : set \u03b1} {p : filter \u03b9} [_inst_2 : topological_space \u03b1], tendsto_locally_uniformly_on F f p s \u2192 s' \u2286 s \u2192 tendsto_locally_uniformly_on F f p s'"}
{"type": "\u2200 {\u03b1 : Type u_1} {M : Type u_5} [_inst_1 : has_one M] [_inst_4 : semilattice_inf M] (f g : \u03b1 \u2192 M), function.mul_support (\u03bb (x : \u03b1), f x \u2293 g x) \u2286 function.mul_support f \u222a function.mul_support g"}
{"type": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [t : topological_space \u03b1] {x : \u03b1}, topological_space.induced (\u03bb (y : \u03b2), x) t = \u22a4"}
{"type": "\u2200 (x y : bool) (n : \u2115), n \u2208 set.Icc x.to_nat y.to_nat \u2192 bool.of_nat n \u2208 set.Icc x y"}
{"type": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] [_inst_2 : category_theory.limits.has_zero_morphisms C] (X Y : C) (i : category_theory.is_iso 0), _ = _"}
{"type": "\u2200 {\u03b1 : Type u} [_inst_1 : linear_ordered_semiring \u03b1] {a b : \u03b1}, 0 < a * b \u2192 (a < 0 \u2194 b < 0)"}
{"type": "\u2200 {R : Type u} [_inst_1 : semiring R], well_founded (\u03bb (p q : polynomial R), p.trailing_degree < q.trailing_degree)"}
{"type": "\u2200 {\u03b1 : Type u_1} {m : set \u03b1 \u2192 ennreal} {m_empty : m \u2205 = 0} (s : set \u03b1), (\u2200 \u2983t : set \u03b1\u2984, s \u2286 t \u2192 m s \u2264 m t) \u2192 (\u2200 (s : \u2115 \u2192 set \u03b1), m (\u22c3 (i : \u2115), s i) \u2264 \u2211' (i : \u2115), m (s i)) \u2192 \u21d1(measure_theory.outer_measure.of_function m m_empty) s = m s"}
{"type": "\u2200 {K : Type u_1} {V : Type u_2} [_inst_1 : field K] [_inst_2 : add_comm_group V] [_inst_3 : module K V], (module.dual.eval K V).ker = \u22a5"}
{"type": "\u2200 (p : \u2115) [_inst_1 : fact (nat.prime p)] (R : Type u\u2081) [_inst_2 : comm_semiring R] [_inst_3 : char_p R p] [_inst_7 : perfect_ring R p] (S : Type u\u2082) [_inst_8 : comm_semiring S] [_inst_9 : char_p S p] (P : Type u\u2083) [_inst_10 : comm_semiring P] [_inst_11 : char_p P p] [_inst_12 : perfect_ring P p] (\u03c0 : P \u2192+* S) (m : perfection_map p \u03c0) (f : R \u2192+* P), \u21d1((perfection_map.lift p R S P \u03c0 m).symm) f = \u03c0.comp f"}
{"type": "uniform_embedding coe"}
{"type": "\u2200 {\u03b9 : Type u_1} {R : Type u_3} {M : Type u_5} [_inst_1 : ring R] [_inst_2 : add_comm_group M] [_inst_5 : module R M] {G : Type u_2} [_inst_8 : group G] [_inst_9 : distrib_mul_action G R] [_inst_10 : distrib_mul_action G M] [_inst_11 : is_scalar_tower G R M] [_inst_12 : smul_comm_class G R M] {v : basis \u03b9 R M} {w : \u03b9 \u2192 G} (i : \u03b9), \u21d1(v.group_smul w) i = (w \u2022 \u21d1v) i"}
{"type": "\u2200 {\u03b1 : Type s} (x y : ulift \u03b1), x.down = y.down \u2192 x = y"}
{"type": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {F : Type u_3} [_inst_4 : normed_group F] [_inst_5 : normed_space \ud835\udd5c F] {f : E \u2192 F} {f\u2080' f\u2081' : E \u2192L[\ud835\udd5c] F} {x : E}, has_fderiv_at f f\u2080' x \u2192 has_fderiv_at f f\u2081' x \u2192 f\u2080' = f\u2081'"}
{"type": "\u2200 {\u03b1 : Type u} {\u03b9 : Sort x} {f : \u03b9 \u2192 \u03b1}, function.surjective f \u2192 set.range f = set.univ"}
{"type": "\u2200 {\u03b1 : Type u_1} {\u03b9 : Type u_2} {s : set \u03b1}, s.nonempty \u2192 \u2200 {f : \u03b1 \u2192 \u03b9}, s.pairwise (\u03bb (x y : \u03b1), f x = f y) \u2194 \u2203 (z : \u03b9), \u2200 (x : \u03b1), x \u2208 s \u2192 f x = z"}
{"type": "\u2200 {\u03b1 : Type u} (l : list \u03b1) (n : \u2115), (l.rotate' n).length = l.length"}
{"type": "\u2200 {R : Type u} {A : Type v} [_inst_1 : comm_ring R] [_inst_2 : ring A] [_inst_3 : algebra R A] {a b : A}, coe \u207b\u00b9' spectrum R (a * b) = coe \u207b\u00b9' spectrum R (b * a)"}
{"type": "\u2200 {\u03b1 : Type u_1}, has_inf.inf = has_inter.inter"}
{"type": "\u2200 {R : Type u_3} {A : Type u_5} [_inst_1 : comm_ring R] [_inst_2 : comm_ring A] [_inst_5 : algebra R A] {s : set A}, algebraic_independent R (\u03bb (x : \u21a5s), \u2191x) \u2194 \u2200 (p : mv_polynomial A R), p \u2208 mv_polynomial.supported R s \u2192 \u21d1(mv_polynomial.aeval id) p = 0 \u2192 p = 0"}
{"type": "\u2200 {R : Type u} {A : Type v} {B : Type w} [_inst_1 : monoid R] [_inst_2 : non_unital_non_assoc_semiring A] [_inst_3 : distrib_mul_action R A] [_inst_4 : non_unital_non_assoc_semiring B] [_inst_5 : distrib_mul_action R B] (f : non_unital_alg_hom R A B), \u21d1\u2191f = \u21d1f"}
{"type": "\u2200 {\u0393 : Type u_1} [_inst_1 : inhabited \u0393] (a b : \u0393) (L R : turing.list_blank \u0393), turing.tape.write b (turing.tape.mk' L (turing.list_blank.cons a R)) = turing.tape.mk' L (turing.list_blank.cons b R)"}
{"type": "\u2200 {G : Type u} {x : G} [_inst_1 : monoid G] {n : \u2115}, order_of x \u2223 n \u2194 x ^ n = 1"}
{"type": "\u2200 {\u03b1 : Type u} [_inst_1 : preorder \u03b1] {a b : \u03b1}, set.Ioc a b \u2286 set.Icc a b"}
{"type": "\u2200 {M : Type u_1} {N : Type u_2} [_inst_1 : mul_one_class M] [_inst_2 : mul_one_class N], \u22a4.prod \u22a4 = \u22a4"}
{"type": "\u2200 (f : circle_deg1_lift) {x : \u211d} {m : \u2124}, \u21d1f x \u2264 x + \u2191m \u2192 f.translation_number \u2264 \u2191m"}
{"type": "\u2200 {R : Type u_1} [_inst_1 : comm_ring R] {M\u2081 : Type u_2} {M\u2082 : Type u_3} [_inst_2 : add_comm_group M\u2081] [_inst_3 : module R M\u2081] [_inst_4 : add_comm_group M\u2082] [_inst_5 : module R M\u2082] {M\u2083 : Type u_4} [_inst_6 : add_comm_group M\u2083] [_inst_7 : module R M\u2083] (f : M\u2081 \u2243\u2097[R] M\u2082) (g : M\u2082 \u2243\u2097[R] M\u2083), g.dual_map.trans f.dual_map = (f.trans g).dual_map"}
{"type": "\u2200 {\u03b1 : Sort u_1} {q : Prop} {p : \u03b1 \u2192 Prop} [_inst_1 : decidable q], (\u2200 (x : \u03b1), p x \u2228 q) \u2194 (\u2200 (x : \u03b1), p x) \u2228 q"}
{"type": "\u2200 {r : \u211d}, 0 \u2264 r \u2192 (ennreal.of_real r).to_real = r"}
{"type": "\u2200 {x : \u211d}, x \u2260 0 \u2192 function.bijective (\u03bb (y : nnreal), y ^ x)"}
{"type": "function.periodic real.tan real.pi"}
{"type": "\u2200 (p : \u2115) [p_prime : fact (nat.prime p)] {q r : \u211a}, q + r \u2260 0 \u2192 linear_order.min (padic_val_rat p q) (padic_val_rat p r) \u2264 padic_val_rat p (q + r)"}
{"type": "\u2200 {\u03b1 : Type u} [_inst_1 : linear_order \u03b1] {a b c : \u03b1}, a < c \u2192 a < linear_order.max b c"}
{"type": "\u2200 {\u03b1 : Type u_1} {m : measurable_space \u03b1} {R : Type u_3} [_inst_1 : semiring R] [_inst_2 : module R \u211d] [_inst_3 : topological_space R] [_inst_4 : has_continuous_smul R \u211d] [_inst_5 : has_continuous_smul R \u2102] (\u1fb0 : measure_theory.signed_measure \u03b1 \u00d7 measure_theory.signed_measure \u03b1), \u21d1(measure_theory.complex_measure.equiv_signed_measure\u2097.symm) \u1fb0 = measure_theory.complex_measure.equiv_signed_measure.inv_fun \u1fb0"}
{"type": "\u2200 {X : Type u_1} {Y : Type u_2} [_inst_1 : topological_space X] [_inst_2 : topological_space Y] [_inst_3 : add_monoid Y] [_inst_4 : has_continuous_add Y] (\u1fb0 : locally_constant X Y), \u21d1locally_constant.to_continuous_map_add_monoid_hom \u1fb0 = \u2191\u1fb0"}
{"type": "\u2200 {J : Type u\u2081} [_inst_1 : category_theory.category J] {C : Type u\u2083} [_inst_3 : category_theory.category C] {F : J \u2964 C\u1d52\u1d56} (c : category_theory.limits.cocone F.left_op) (X : J), (category_theory.limits.cone_of_cocone_left_op c).\u03c0.app X = (c.\u03b9.app (opposite.op X)).op"}
{"type": "\u2200 {G : Type u} [_inst_1 : group G] (a b : G), a * b\u207b\u00b9 * b = a"}
{"type": "\u2200 {s : set \u2115} {m : \u2115}, m \u2208 s \u2192 has_Inf.Inf s \u2264 m"}
{"type": "\u2200 (n : \u2115), 1 < n \u2192 (\u2200 (m : \u2115), m < n \u2192 m \u2260 0 \u2192 n.coprime m) \u2192 nat.prime n"}
{"type": "\u2200 {\u03b1 : Type u_1} {R : \u03b1 \u2192 \u03b1 \u2192 Prop} [_inst_1 : decidable_rel R] {l : list \u03b1}, list.pw_filter R (list.pw_filter R l) = list.pw_filter R l"}
{"type": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] [_inst_2 : category_theory.monoidal_category C] [_inst_3 : category_theory.braided_category C] {D : Type u\u2082} [_inst_4 : category_theory.category D] [_inst_5 : category_theory.monoidal_category D] [_inst_6 : category_theory.braided_category D] {F G : category_theory.lax_braided_functor C D} (i : F.to_lax_monoidal_functor \u2245 G.to_lax_monoidal_functor), (category_theory.lax_braided_functor.mk_iso i).hom = i.hom"}
{"type": "\u2200 {\u03b1 : Type u_1} {\u03b9 : Type u_2} [_inst_1 : semilattice_inf \u03b1] [_inst_2 : order_bot \u03b1] {s t : set \u03b9} {f : \u03b9 \u2192 \u03b1}, t.pairwise_disjoint f \u2192 s \u2286 t \u2192 s.pairwise_disjoint f"}
{"type": "\u2200 {R : Type u} {L : Type v} {M : Type w} {M' : Type w\u2081} [_inst_1 : comm_ring R] [_inst_2 : lie_ring L] [_inst_3 : lie_algebra R L] [_inst_6 : add_comm_group M] [_inst_7 : module R M] [_inst_8 : lie_ring_module L M] [_inst_9 : lie_module R L M] [_inst_10 : add_comm_group M'] [_inst_11 : module R M'] [_inst_12 : lie_ring_module L M'] [_inst_13 : lie_module R L M'] (f : M \u2192\u2097\u2045R,L\u2046 M'), galois_connection (lie_submodule.map f) (lie_submodule.comap f)"}
{"type": "\u2200 {J : Type u\u2081} [_inst_1 : category_theory.category J] {C : Type u\u2083} [_inst_3 : category_theory.category C] {F : J \u2964 C} {r s t : category_theory.limits.cocone F} (P : category_theory.limits.is_colimit s) (Q : category_theory.limits.is_colimit t) {X' : C} (f' : r.X \u27f6 X'), (P.cocone_point_unique_up_to_iso Q).hom \u226b Q.desc r \u226b f' = P.desc r \u226b f'"}
{"type": "\u2200 {x : \u211d*} {r : \u211d}, \u00acx.infinitesimal \u2192 x.is_st r \u2192 x\u207b\u00b9.is_st r\u207b\u00b9"}
{"type": "\u2200 {\u03b1 : Type u_1} {M : Type u_4} [_inst_1 : comm_monoid M] {f : \u03b1 \u2192 M} (p : \u03b1 \u2192 Prop), finprod (\u03bb (j : subtype p), f \u2191j) = finprod (\u03bb (i : \u03b1), finprod (\u03bb (hi : p i), f i))"}
{"type": "\u2200 {R : Type u_1} {R\u2082 : Type u_3} {R\u2083 : Type u_4} {R\u2084 : Type u_5} {M : Type u_9} {M\u2082 : Type u_12} {M\u2083 : Type u_13} {M\u2084 : Type u_14} [_inst_1 : semiring R] [_inst_2 : semiring R\u2082] [_inst_3 : semiring R\u2083] [_inst_4 : semiring R\u2084] [_inst_5 : add_comm_monoid M] [_inst_7 : add_comm_monoid M\u2082] [_inst_8 : add_comm_monoid M\u2083] [_inst_9 : add_comm_monoid M\u2084] [_inst_10 : module R M] [_inst_12 : module R\u2082 M\u2082] [_inst_13 : module R\u2083 M\u2083] [_inst_14 : module R\u2084 M\u2084] {\u03c3\u2081\u2082 : R \u2192+* R\u2082} {\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083} {\u03c3\u2083\u2084 : R\u2083 \u2192+* R\u2084} {\u03c3\u2081\u2083 : R \u2192+* R\u2083} {\u03c3\u2082\u2084 : R\u2082 \u2192+* R\u2084} {\u03c3\u2081\u2084 : R \u2192+* R\u2084} [_inst_15 : ring_hom_comp_triple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083] [_inst_16 : ring_hom_comp_triple \u03c3\u2082\u2083 \u03c3\u2083\u2084 \u03c3\u2082\u2084] [_inst_17 : ring_hom_comp_triple \u03c3\u2081\u2083 \u03c3\u2083\u2084 \u03c3\u2081\u2084] [_inst_18 : ring_hom_comp_triple \u03c3\u2081\u2082 \u03c3\u2082\u2084 \u03c3\u2081\u2084] (f : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) (g : M\u2082 \u2192\u209b\u2097[\u03c3\u2082\u2083] M\u2083) (h : M\u2083 \u2192\u209b\u2097[\u03c3\u2083\u2084] M\u2084), (h.comp g).comp f = h.comp (g.comp f)"}
{"type": "\u2200 (m n k : \u2115), (m.lcm n).lcm k = m.lcm (n.lcm k)"}
{"type": "\u2200 {X : Type u_1} [_inst_1 : topological_space X] {Y : Type u_2} [_inst_2 : topological_space Y] {f : Y \u2192 X} {cont : continuous f} {A : discrete_quotient Y} {B : discrete_quotient X} {C : discrete_quotient Y} (cond : discrete_quotient.le_comap cont A B) (h : C \u2264 A) (c : \u21a5C), discrete_quotient.map _ c = discrete_quotient.map cond (discrete_quotient.of_le h c)"}
{"type": "\u2200 {\u03b1 : Type u} [_inst_1 : topological_space \u03b1] [_inst_2 : preconnected_space \u03b1] {s : set \u03b1}, s.nonempty \u2192 is_clopen s \u2192 s = set.univ"}
{"type": "\u2200 {f : cau_seq.completion.Cauchy}, \u27e8f\u27e9\u207b\u00b9 = \u27e8f\u207b\u00b9\u27e9"}
{"type": "\u2200 {n : Type u} [_inst_1 : decidable_eq n] [_inst_2 : fintype n] {R : Type v} [_inst_3 : comm_ring R] (A : GL n R), \u2191A\u207b\u00b9 = (\u2191A)\u207b\u00b9"}
{"type": "\u2200 {\u03b1 : Type u_1} [_inst_1 : group \u03b1] {s : subgroup \u03b1} {a b : \u03b1}, quotient_group.mk a = quotient_group.mk b \u2194 a\u207b\u00b9 * b \u2208 s"}
{"type": "\u2200 {M : Type u_1} [_inst_1 : mul_one_class M] {S : set (submonoid M)} {x : M}, x \u2208 has_Inf.Inf S \u2194 \u2200 (p : submonoid M), p \u2208 S \u2192 x \u2208 p"}
{"type": "\u2200 {\u03b1 : Type u} [_inst_1 : topological_space \u03b1] [_inst_3 : locally_compact_space \u03b1] {x : \u03b1} {U : set \u03b1}, is_open U \u2192 x \u2208 U \u2192 (\u2203 (K : set \u03b1), is_compact K \u2227 x \u2208 interior K \u2227 K \u2286 U)"}
{"type": "\u2200 {M : Type u_1} {N : Type u_2} [_inst_1 : mul_one_class M] [_inst_2 : mul_one_class N] {f : M \u2192* N}, function.surjective \u21d1f \u2192 function.injective (submonoid.comap f)"}
{"type": "\u2200 {V : Type u} {G : simple_graph V} (d : G.dart), d.edge \u2208 G.edge_set"}
{"type": "\u2200 {G : Type u} [_inst_1 : add_left_cancel_semigroup G] (a : G) {b c : G}, a + b \u2260 a + c \u2194 b \u2260 c"}
{"type": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {D : Type u\u2082} [_inst_2 : category_theory.category D] {F : C \u2964 D} [_inst_3 : category_theory.full F] [_inst_4 : category_theory.faithful F] {X : C}, F.preimage (\ud835\udfd9 (F.obj X)) = \ud835\udfd9 X"}
{"type": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] [_inst_2 : category_theory.monoidal_category C] {X Y Z : C} [_inst_3 : category_theory.has_right_dual X] [_inst_4 : category_theory.has_right_dual Y] [_inst_5 : category_theory.has_right_dual Z] {f : X \u27f6 Y} {g : Y \u27f6 Z} {X' : C} (f' : X\u1601 \u27f6 X'), (f \u226b g)\u1601 \u226b f' = g\u1601 \u226b f\u1601 \u226b f'"}
{"type": "\u2200 {\u03b1 : Type u_1} {s t u : set \u03b1} [_inst_1 : has_add \u03b1], s \u222a t + u = s + u \u222a (t + u)"}
{"type": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] [_inst_2 : category_theory.preadditive C] [_inst_3 : category_theory.has_shift C \u2124] [_inst_4 : \u2200 (n : \u2124), (category_theory.shift_functor C n).additive], category_theory.triangulated.triangle_rotation.counit_iso = category_theory.triangulated.inv_rot_comp_rot"}
{"type": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {op : \u03b2 \u2192 \u03b2 \u2192 \u03b2} [hc : is_commutative \u03b2 op] [ha : is_associative \u03b2 op] {f : \u03b1 \u2192 \u03b2} {b : \u03b2} {s : finset \u03b1} [_inst_1 : is_idempotent \u03b2 op] {g : \u03b1 \u2192 \u03b2} (p : \u03b1 \u2192 Prop) [_inst_2 : decidable_pred p], finset.fold op b (\u03bb (i : \u03b1), ite (p i) (f i) (g i)) s = op (finset.fold op b f (finset.filter p s)) (finset.fold op b g (finset.filter (\u03bb (i : \u03b1), \u00acp i) s))"}
{"type": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {f : \u03b1 \u2192 \u03b2} {ga : \u03b1 \u2192 \u03b1 \u2192 \u03b1} {gb : \u03b2 \u2192 \u03b2 \u2192 \u03b2} [_inst_1 : is_associative \u03b1 ga], function.semiconj\u2082 f ga gb \u2192 function.surjective f \u2192 is_associative \u03b2 gb"}
{"type": "\u2200 {\u03b1 : Type u_1} [_inst_1 : decidable_eq \u03b1] {a : \u03b1} {s t : multiset \u03b1}, multiset.ndinsert a s \u2264 t \u2194 s \u2264 t \u2227 a \u2208 t"}
{"type": "\u2200 {x : \u211d}, -1 \u2264 x \u2192 x \u2264 1 \u2192 real.sin (real.arccos x) = real.sqrt (1 - x ^ 2)"}
{"type": "\u2200 {p x : \u211d}, liouville_with p x \u2192 \u2200 (n : \u2115), liouville_with p (\u2191n + x)"}
{"type": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {D : Type u\u2082} [_inst_2 : category_theory.category D] [_inst_3 : category_theory.monoidal_category D] {F : C \u2964 D} {X : C}, (\u03c1_ F).hom.app X = (\u03c1_ (F.obj X)).hom"}
{"type": "\u2200 {\u03b1 : Type u} {x y : ulift \u03b1} [_inst_1 : has_add \u03b1], (x + y).down = x.down + y.down"}
{"type": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {\u03b3 : Type u_3} [_inst_1 : decidable_eq \u03b2] [_inst_2 : decidable_eq \u03b3] {s : finset \u03b1} {t : \u03b1 \u2192 finset \u03b2} {f : \u03b2 \u2192 \u03b3}, finset.image f (s.bUnion t) = s.bUnion (\u03bb (a : \u03b1), finset.image f (t a))"}
{"type": "\u2200 (o : ordinal), o.pred \u2264 o"}
{"type": "\u2200 {\u03b1 : Type u_1} {s : finset \u03b1}, s.nonempty \u2192 s \u2260 \u2205"}
{"type": "\u2200 {G : Type u_1} [_inst_1 : add_group G] {s : set G}, is_add_subgroup s \u2192 s \u2286 is_add_subgroup.add_normalizer s"}
{"type": "\u2200 {\u03b1 : Type u_1} [_inst_1 : preorder \u03b1] [_inst_2 : locally_finite_order \u03b1] {a b x : \u03b1}, x \u2208 finset.Ioo a b \u2194 a < x \u2227 x < b"}
{"type": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {f : \u03b1 \u2192 \u03b2} {s t : multiset \u03b1}, s \u2264 t \u2192 multiset.map f s \u2264 multiset.map f t"}
{"type": "\u2200 {\u03b1 : Type u_1} [_inst_1 : complete_lattice \u03b1], has_Sup.Sup set.univ = \u22a4"}
{"type": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {\u03b9 : Type u_4} [_inst_1 : measurable_space \u03b1] [_inst_2 : measurable_space \u03b2] {f : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {\u03bc : measure_theory.measure \u03b1} {p : \u03b1 \u2192 (\u03b9 \u2192 \u03b2) \u2192 Prop} [_inst_3 : encodable \u03b9] (hf : \u2200 (i : \u03b9), ae_measurable (f i) \u03bc), (\u2200\u1d50 (x : \u03b1) \u2202\u03bc, p x (\u03bb (n : \u03b9), f n x)) \u2192 (\u2200\u1d50 (a : \u03b1) \u2202\u03bc, \u2200 (i : \u03b9), ae_seq hf p i a = f i a)"}
{"type": "\u2200 {R : Type u} [_inst_1 : comm_ring R] {f : polynomial R}, \u21d1(adjoin_root.mk f) f = 0"}
{"type": "\u2200 {R : Type u} [_inst_1 : comm_ring R], prime_spectrum.zero_locus {1} = \u2205"}
{"type": "\u2200 {s : set \u211d} {x : \u211d}, x \u2208 closure s \u2194 \u2200 (\u03b5 : \u211d), \u03b5 > 0 \u2192 (\u2203 (y : \u211d) (H : y \u2208 s), |y - x| < \u03b5)"}
{"type": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {D : Type u\u2082} [_inst_2 : category_theory.category D] (e : C \u224c D), e.symm.counit_iso = e.unit_iso.symm"}
{"type": "\u2200 {G : Type u_1} {P : Type u_2} {G' : Type u_3} {P' : Type u_4} [_inst_1 : add_group G] [_inst_2 : add_group G'] [_inst_3 : add_torsor G P] [_inst_4 : add_torsor G' P'] (v : G \u00d7 G') (p : P \u00d7 P'), (v +\u1d65 p).fst = v.fst +\u1d65 p.fst"}
{"type": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {g : \u03b2 \u2192 \u03b1}, topological_space.induced g \u22a4 = \u22a4"}
{"type": "\u2200 {\u03c4 : Type u_1} [_inst_1 : add_monoid \u03c4] [_inst_2 : topological_space \u03c4] [_inst_3 : has_continuous_add \u03c4] {\u03b1 : Type u_2} [_inst_4 : topological_space \u03b1] (\u03d5 : flow \u03c4 \u03b1) {\u03b2 : Type u_3} [_inst_5 : topological_space \u03b2] {t : \u03b2 \u2192 \u03c4}, continuous t \u2192 \u2200 {f : \u03b2 \u2192 \u03b1}, continuous f \u2192 continuous (\u03bb (x : \u03b2), \u21d1\u03d5 (t x) (f x))"}
{"type": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_2 : decidable_eq \u03b2] {s : finset \u03b1} {t : finset \u03b2} {f : \u03b1 \u2192 \u03b2} {n : \u2115}, (\u2200 (a : \u03b1), a \u2208 s \u2192 f a \u2208 t) \u2192 t.nonempty \u2192 t.card * n \u2264 s.card \u2192 (\u2203 (y : \u03b2) (H : y \u2208 t), n \u2264 (finset.filter (\u03bb (x : \u03b1), f x = y) s).card)"}
{"type": "\u2200 {\u03b1 : Type u_1} [_inst_1 : topological_space \u03b1] {\u03b2 : Type u_2} [_inst_2 : preorder \u03b2] {f : \u03b1 \u2192 \u03b2}, lower_semicontinuous f \u2194 \u2200 (y : \u03b2), is_open (f \u207b\u00b9' set.Ioi y)"}
{"type": "\u2200 {\u03b1 : Type u_1} {p : \u03b1 \u2192 Prop} [_inst_1 : decidable_pred p] {a : \u03b1} {s : multiset \u03b1}, a \u2208 multiset.filter p s \u2192 a \u2208 s"}
{"type": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {\u03b3 : Type u_3} {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {s : set \u03b1} {t : set \u03b2} {u : set \u03b3}, set.image2 f s t \u2286 u \u2194 \u2200 (x : \u03b1), x \u2208 s \u2192 \u2200 (y : \u03b2), y \u2208 t \u2192 f x y \u2208 u"}
{"type": "\u2200 {R : Type u} {L : Type v} {L' : Type w\u2082} [_inst_1 : comm_ring R] [_inst_2 : lie_ring L] [_inst_3 : lie_algebra R L] [_inst_4 : lie_ring L'] [_inst_5 : lie_algebra R L'] (f : L \u2192\u2097\u2045R\u2046 L'), f.is_ideal_morphism \u2194 \u2191(f.ideal_range) = f.range"}
{"type": "\u2200 {\u03b1 : Type u_1} (b : buffer \u03b1) (a : \u03b1), (b.push_back a).size = b.size + 1"}
{"type": "\u2200 {\u03b1 : Type u} {s t u : set \u03b1}, s \u2286 t \u2192 t \u2286 u \u2192 t \u222a u \\ s = u"}
{"type": "\u2200 {E : Type u_1} [_inst_1 : normed_group E] [_inst_2 : normed_space \u211d E] {f : E \u2192 \u211d} {n : with_top \u2115} {x : E}, times_cont_diff_at \u211d n f x \u2192 f x \u2260 0 \u2192 times_cont_diff_at \u211d n (\u03bb (y : E), real.sqrt (f y)) x"}
{"type": "\u2200 {A : Type u\u2081} [_inst_1 : category_theory.category A] {B : Type u\u2082} [_inst_2 : category_theory.category B] {T : Type u\u2083} [_inst_3 : category_theory.category T] (L : A \u2964 T) (R : B \u2964 T) (X Y : category_theory.comma L R) (H : X = Y), (category_theory.eq_to_hom H).right = category_theory.eq_to_hom _"}
{"type": "\u2200 {k : Type u_2} [_inst_1 : field k] {\u03c6 \u03c8 : power_series k}, \u21d1(power_series.constant_coeff k) \u03c8 \u2260 0 \u2192 (\u03c6 = \u03c8\u207b\u00b9 \u2194 \u03c6 * \u03c8 = 1)"}
{"type": "\u21912\u207b\u00b9 = 2\u207b\u00b9"}
{"type": "\u2200 {E : Type u_1} {F : Type u_2} [_inst_1 : inner_product_space \u211d E] [_inst_2 : inner_product_space \u211d F] {f : E \u2192 F} {x : E} {f' : E \u2192L[\u211d] F}, has_fderiv_at f f' x \u2192 \u2200 (H : conformal_at f x) (u v : E), has_inner.inner (\u21d1f' u) (\u21d1f' v) = conformal_factor_at H * has_inner.inner u v"}
{"type": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {f : filter \u03b2} {m : \u03b1 \u2192 \u03b2}, (filter.comap m f).ne_bot \u2194 (set.range m)\u1d9c \u2209 f"}
{"type": "\u2200 {x : \u211d}, irrational x \u2192 \u2200 (m : \u2115), irrational (\u2191m - x)"}
{"type": "\u2200 {\u03b9 : Type u_1} {\u03b9' : Type u_2} {\u03b1 : Type u_3} {\u03b2 : Type u_4} [_inst_1 : preorder \u03b1] [_inst_2 : preorder \u03b2] {f : \u03b9 \u2192 \u03b1} {g : \u03b9 \u2192 \u03b2}, monovary f g \u2192 \u2200 (k : \u03b9' \u2192 \u03b9), monovary (f \u2218 k) (g \u2218 k)"}
{"type": "\u2200 {G : Type u_1} [_inst_1 : add_group G] (K : add_subgroup G) {k : set G}, add_subgroup.closure k \u2264 K \u2194 k \u2286 \u2191K"}
{"type": "\u2200 {I : Type w\u2080} {C : I \u2192 Type u\u2081} [_inst_1 : \u03a0 (i : I), category_theory.category (C i)] {D : I \u2192 Type u\u2081} [_inst_2 : \u03a0 (i : I), category_theory.category (D i)] (F : \u03a0 (i : I), C i \u2964 D i) (f : \u03a0 (i : I), C i) (i : I), (category_theory.functor.pi F).obj f i = (F i).obj (f i)"}
{"type": "\u2200 {n m : \u2115}, n \u2208 m.divisors \u2192 n \u2264 m"}
{"type": "\u2200 {K : Type u_1} [_inst_1 : is_R_or_C K] {r : \u211d}, 0 \u2264 r \u2192 \u2225\u2191r\u2225 = r"}
{"type": "\u2200 (V : Type u) [_inst_1 : category_theory.category V] [_inst_2 : category_theory.limits.has_zero_morphisms V] {\u03b9 : Type u_1} (c : complex_shape \u03b9) {\u03b9' : Type u_2} (c' : complex_shape \u03b9'), (homological_complex.flip_equivalence V c c').counit_iso = homological_complex.flip_equivalence_counit_iso V c c'"}
{"type": "\u2200 {X : Type u_1} {Y : Type u_2} [_inst_1 : topological_space X] [_inst_2 : topological_space Y] (f : locally_constant X Y), \u21d1\u2191f = \u21d1f"}
{"type": "\u2200 {\u03b1 : Type u_1} {m : multiset \u03b1} {a : \u03b1} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {n : \u2115}, multiset.rel r (multiset.repeat a n) m \u2194 \u21d1multiset.card m = n \u2227 \u2200 (x : \u03b1), x \u2208 m \u2192 r a x"}
{"type": "\u2200 {R : Type u} [_inst_1 : comm_ring R] {n : Type v} [_inst_2 : decidable_eq n] [_inst_3 : fintype n] [_inst_5 : nontrivial R] (M : matrix n n R), M.charpoly.nat_degree = fintype.card n"}
{"type": "\u2200 {\ud835\udd5c : Type u_1} {E : Type u_2} [_inst_1 : ordered_semiring \ud835\udd5c] [_inst_2 : add_comm_monoid E] [_inst_4 : has_scalar \ud835\udd5c E] {S : set (set E)}, (\u2200 (s : set E), s \u2208 S \u2192 convex \ud835\udd5c s) \u2192 convex \ud835\udd5c (\u22c2\u2080 S)"}
{"type": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : has_zero \u03b1] [_inst_2 : has_zero \u03b2] [_inst_3 : smul_with_zero \u03b1 \u03b2] {s : set \u03b2}, s.nonempty \u2192 0 \u2022 s = 0"}
{"type": "\u2200 {X : Type u_1} {Y : Type u_2} [_inst_1 : topological_space X] [_inst_2 : preconnected_space X] [_inst_3 : nonempty Y] (f : locally_constant X Y), \u2203 (y : Y), f = locally_constant.const X y"}
{"type": "\u2200 {F : pfunctor} (x : F.obj F.M), (pfunctor.M.mk x).head = x.fst"}
{"type": "\u2200 {M : Type u} [_inst_1 : add_monoid M] {N : Type u} [_inst_2 : add_monoid N] (F : M \u2192+ N) (X Y : category_theory.discrete M) (f : X \u27f6 Y), (dicrete.add_monoidal_functor F).to_lax_monoidal_functor.to_functor.map f = category_theory.eq_to_hom _"}
{"type": "\u2200 {\u03b1 : Type u_1} [_inst_1 : topological_space \u03b1] [_inst_2 : t1_space \u03b1] [_inst_3 : topological_space.first_countable_topology \u03b1] {s : set \u03b1}, s.finite \u2192 is_G\u03b4 s"}
{"type": "\u2200 {\u03b1 : Type u_1} {l : list \u03b1}, l <:+: l"}
{"type": "\u2200 {M : Type uM} {N : Type uN} {P : Type uP} {mM : add_zero_class M} {mN : add_zero_class N} {mP : add_comm_monoid P} (f : M \u2192+ N \u2192+ P), \u21d1add_monoid_hom.flip_hom f = f.flip"}
{"type": "\u2200 {R : Type u} [_inst_1 : comm_semiring R] {I J : ideal R}, I.radical \u2264 J.radical \u2194 I \u2264 J.radical"}
{"type": "\u2200 {\u03b1 : Type u_1} [_inst_1 : primcodable \u03b1] (f : bool \u2192 \u03b1), primrec f"}
{"type": "\u2200 {R : Type u} {A\u2081 : Type v} {A\u2082 : Type w} {A\u2083 : Type u\u2081} [_inst_1 : comm_semiring R] [_inst_2 : semiring A\u2081] [_inst_3 : semiring A\u2082] [_inst_4 : semiring A\u2083] [_inst_5 : algebra R A\u2081] [_inst_6 : algebra R A\u2082] [_inst_7 : algebra R A\u2083] (e\u2081 : A\u2081 \u2243\u2090[R] A\u2082) (e\u2082 : A\u2082 \u2243\u2090[R] A\u2083) (x : A\u2081), \u21d1(e\u2081.trans e\u2082) x = \u21d1e\u2082 (\u21d1e\u2081 x)"}
{"type": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : pseudo_metric_space \u03b1] [_inst_2 : pseudo_metric_space \u03b2] (h : \u03b1 \u2243\u1d62 \u03b2) (s : set \u03b2), metric.diam (\u21d1h \u207b\u00b9' s) = metric.diam s"}
{"type": "\u2200 {B : Type u_1} (E : B \u2192 Type u_2) (x : B) (v : E x), \u2191v.fst = x"}
{"type": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {\u03b3 : Type u_3} {\u03b4 : Type u_4} {\u03c3 : Type u_5} [_inst_1 : primcodable \u03b1] [_inst_2 : primcodable \u03b2] [_inst_3 : primcodable \u03b3] [_inst_4 : primcodable \u03b4] [_inst_5 : primcodable \u03c3] {f : \u03b3 \u2192 \u03b4 \u2192 \u03c3} {g : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {h : \u03b1 \u2192 \u03b2 \u2192 \u03b4}, computable\u2082 f \u2192 computable\u2082 g \u2192 computable\u2082 h \u2192 computable\u2082 (\u03bb (a : \u03b1) (b : \u03b2), f (g a b) (h a b))"}
{"type": "cardinal.mk \u21a5set.univ = cardinal.continuum"}
{"type": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} [_inst_1 : is_refl \u03b1 r] [_inst_2 : is_refl \u03b2 s], r \u2243r s \u2192 (order.cof r).lift = (order.cof s).lift"}
{"type": "\u2200 {z : \u2124}, z \u2260 0 \u2192 |z.sign| = 1"}
{"type": "\u2200 {\u03b1 : Type u} [_inst_1 : pseudo_metric_space \u03b1] {\u03b2 : Type u_1} {p : \u03b2 \u2192 Prop} {f : \u03b2 \u2192 \u211d}, (\u2200 (i : \u03b2), p i \u2192 0 < f i) \u2192 (\u2200 \u2983\u03b5 : \u211d\u2984, 0 < \u03b5 \u2192 (\u2203 (i : \u03b2) (hi : p i), f i \u2264 \u03b5)) \u2192 (uniformity \u03b1).has_basis p (\u03bb (i : \u03b2), {p : \u03b1 \u00d7 \u03b1 | has_dist.dist p.fst p.snd < f i})"}
{"type": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : topological_space \u03b1] [_inst_2 : compact_space \u03b1] [_inst_3 : metric_space \u03b2] (x : \u03b1), continuous (\u03bb (f : C(\u03b1, \u03b2)), \u21d1f x)"}
{"type": "\u2200 {\u03b2 : Type v} (r : \u03b2 \u2192 \u03b2 \u2192 Prop) [_inst_2 : is_refl \u03b2 r] [_inst_3 : is_trans \u03b2 r] {f : \u2124 \u2192 \u03b2}, (\u2200 (n : \u2124), r (f n) (f (n + 1))) \u2192 \u2200 \u2983a b : \u2124\u2984, a \u2264 b \u2192 r (f a) (f b)"}
{"type": "\u2200 {a : ordinal} {b : ordinal}, b < a.lift \u2194 \u2203 (a' : ordinal), a'.lift = b \u2227 a' < a"}
{"type": "\u2200 {R : Type x} [_inst_1 : distrib R] (a b c : R), a * (b + c) = a * b + a * c"}
{"type": "int.bitwise bor = int.lor"}
{"type": "\u2200 {M : Type uM} {N : Type uN} {P : Type uP} {mM : mul_one_class M} {mN : mul_one_class N} {mP : comm_monoid P} (f : M \u2192* N \u2192* P) (n : N), \u21d1(\u21d1f 1) n = 1"}
{"type": "\u2200 {\u03b1 : Type u_1} [_inst_1 : normed_field \u03b1] (a : \u03b1), \u2225a\u207b\u00b9\u2225 = \u2225a\u2225\u207b\u00b9"}
{"type": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] [_inst_2 : category_theory.has_shift C \u2124] {T\u2081 T\u2082 T\u2083 : category_theory.triangulated.triangle C} (f : category_theory.triangulated.triangle_morphism T\u2081 T\u2082) (g : category_theory.triangulated.triangle_morphism T\u2082 T\u2083), (f.comp g).hom\u2082 = f.hom\u2082 \u226b g.hom\u2082"}
{"type": "\u2200 {\u03b1 : Type u_1} {F : Type u_4} {E' : Type u_6} [_inst_2 : has_norm F] [_inst_4 : normed_group E'] {c : \u211d} {g : \u03b1 \u2192 F} {f' : \u03b1 \u2192 E'} {l : filter \u03b1}, asymptotics.is_O_with c (\u03bb (x : \u03b1), \u2225f' x\u2225) g l \u2194 asymptotics.is_O_with c f' g l"}
{"type": "\u2200 {R : Type u_1} {V : Type u_2} [_inst_1 : ring R] [_inst_2 : invertible 2] [_inst_3 : add_comm_group V] [_inst_4 : module R V] (v\u2081 v\u2082 : V), v\u2081 - midpoint R v\u2081 v\u2082 = \u215f 2 \u2022 (v\u2081 - v\u2082)"}
{"type": "\u2200 {\u03b1 : Type u_1} [_inst_1 : measurable_space \u03b1] {\u03bc : measure_theory.measure \u03b1} {s t : set \u03b1}, s \u2264\u1d50[\u03bc] t \u2192 \u21d1\u03bc s \u2264 \u21d1\u03bc t"}
{"type": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {H : Type u_3} [_inst_4 : topological_space H] {I : model_with_corners \ud835\udd5c E H} {M : Type u_4} [_inst_5 : topological_space M] [_inst_6 : charted_space H M] [Is : smooth_manifold_with_corners I M] {E' : Type u_5} [_inst_7 : normed_group E'] [_inst_8 : normed_space \ud835\udd5c E'] {H' : Type u_6} [_inst_9 : topological_space H'] {I' : model_with_corners \ud835\udd5c E' H'} {M' : Type u_7} [_inst_10 : topological_space M'] [_inst_11 : charted_space H' M'] [I's : smooth_manifold_with_corners I' M'] {f : M \u2192 M'}, smooth I I' f \u2194 continuous f \u2227 \u2200 (x : M) (y : M'), times_cont_diff_on \ud835\udd5c \u22a4 (\u21d1(ext_chart_at I' y) \u2218 f \u2218 \u21d1((ext_chart_at I x).symm)) ((ext_chart_at I x).target \u2229 \u21d1((ext_chart_at I x).symm) \u207b\u00b9' (f \u207b\u00b9' (ext_chart_at I' y).source))"}
{"type": "\u2200 {\u03b1 : Type u} (s : wseq \u03b1), s.think ~ s"}
{"type": "\u2200 {G : Type u} [_inst_1 : ordered_add_comm_group G] (a b : G), (\u03bb (x : G), x - a) '' set.Ici b = set.Ici (b - a)"}
{"type": "\u2200 {\u03b1 : Sort u_1} {\u03b2 : Sort u_2} (f : \u03b1 \u2192 \u03b2) (c : \u2200 (a b : \u03b1), f a = f b) (a : \u03b1), trunc.lift f c (trunc.mk a) = f a"}
{"type": "\u2200 {\u03b1 : Sort u} {\u03b2 : Sort v} {p : \u03b1 \u2192 Prop} {q : \u03b2 \u2192 Prop} (f : \u03b1 \u2243 \u03b2), (\u2200 {x : \u03b1}, p x \u2194 q (\u21d1f x)) \u2192 ((\u2203! (x : \u03b1), p x) \u2194 \u2203! (y : \u03b2), q y)"}
{"type": "\u2200 {\u03b1 : Type u_1} {f : \u03b1 \u2192 nnreal}, summable f \u2192 \u2191(tsum f) = \u2211' (a : \u03b1), \u2191(f a)"}
{"type": "\u2200 (r : \u211d), convex \u211d {c : \u2102 | c.im \u2264 r}"}
{"type": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : topological_space \u03b1] [_inst_2 : preorder \u03b1] [t : order_closed_topology \u03b1] {f : \u03b2 \u2192 \u03b1} {a b : \u03b1} {x : filter \u03b2} [_inst_3 : x.ne_bot], filter.tendsto f x (nhds a) \u2192 (\u2200\u1da0 (c : \u03b2) in x, b \u2264 f c) \u2192 b \u2264 a"}
{"type": "\u2200 {\u03b1 : Type u_1} {m : measurable_space \u03b1} {M : Type u_3} [_inst_1 : add_comm_monoid M] [_inst_2 : topological_space M] {s t : measure_theory.vector_measure \u03b1 M}, (\u2200 (i : set \u03b1), measurable_set i \u2192 \u21d1s i = \u21d1t i) \u2192 s = t"}
{"type": "\u2200 {R\u2081 : Type u_1} {R\u2082 : Type u_2} {R\u2083 : Type u_3} [_inst_1 : semiring R\u2081] [_inst_2 : semiring R\u2082] [_inst_3 : semiring R\u2083] {\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082} {\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083} {\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083} [_inst_4 : ring_hom_comp_triple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083] {x : R\u2081}, \u21d1\u03c3\u2082\u2083 (\u21d1\u03c3\u2081\u2082 x) = \u21d1\u03c3\u2081\u2083 x"}
{"type": "\u2200 {\u03b1 : Type u_1} [_inst_1 : fintype \u03b1] [_inst_2 : decidable_eq \u03b1] {g : equiv.perm \u03b1}, g.is_three_cycle \u2192 (g * g).is_three_cycle"}
{"type": "\u2200 {\u03b1 : Type u} (s : finset \u03b1), {a : \u03b1 | a \u2208 s}.finite"}
{"type": "\u2200 {\u03b1 : Type u_1} (s : finset \u03b1), s.attach.val = s.val.attach"}
{"type": "\u2200 {M : Type u_1} {P : Type u_3} [_inst_1 : add_zero_class M] [_inst_3 : add_zero_class P] (f : M \u2192+ P), function.injective \u21d1(add_con.ker_lift f)"}
{"type": "\u2200 (n : \u2115), \u2191(n / n) = \u2191n / \u2191n"}
{"type": "\u2200 {\u03b1 : Type u_1} {a b c : \u03b1} [_inst_1 : preorder \u03b1] [_inst_2 : add_zero_class \u03b1] [_inst_3 : covariant_class \u03b1 \u03b1 has_add.add has_le.le], a + b < c \u2192 0 \u2264 b \u2192 a < c"}
{"type": "\u2200 {\ud835\udd5c : Type u_1} {\u03b2 : Type u_4} [_inst_1 : ordered_semiring \ud835\udd5c] [_inst_6 : ordered_add_comm_monoid \u03b2] [_inst_7 : module \ud835\udd5c \u03b2] [_inst_8 : ordered_smul \ud835\udd5c \u03b2] (r s : \u03b2), convex \ud835\udd5c (set.Icc r s)"}
{"type": "\u2200 {z : \u2102}, z.im < 0 \u2192 z.arg = -real.arccos (z.re / complex.abs z)"}
{"type": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] (I : category_theory.limits.multicospan_index C) (P : C) (\u03b9 : \u03a0 (a : I.L), P \u27f6 I.left a) (w : \u2200 (b : I.R), \u03b9 (I.fst_to b) \u226b I.fst b = \u03b9 (I.snd_to b) \u226b I.snd b), (category_theory.limits.multifork.of_\u03b9 I P \u03b9 w).X = P"}
{"type": "\u2200 {E : Type u_5} [_inst_25 : semi_normed_group E] {R' : Type u_10} [_inst_35 : ring R'] [_inst_36 : module R' E] (p : submodule R' E), \u21d1(p.subtype\u2097\u1d62) = \u21d1(p.subtype)"}
{"type": "\u2200 {\u03b1 : Type u} [_inst_1 : topological_space \u03b1] {s : set \u03b1}, s.nonempty \u2192 (closure s).nonempty"}
{"type": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] [_inst_2 : category_theory.preadditive C] [_inst_3 : category_theory.has_shift C \u2124] (_x _x_1 : category_theory.triangulated.triangle C) (f : _x \u27f6 _x_1), category_theory.triangulated.inv_rotate.map f = category_theory.triangulated.triangle_morphism.inv_rotate f"}
{"type": "\u2200 {X : Type u_1} {Y : Type u_2} [_inst_1 : topological_space X] {f : X \u2192 Y}, is_locally_constant f \u2192 \u2200 {s : set X}, is_preconnected s \u2192 \u2200 {x y : X}, x \u2208 s \u2192 y \u2208 s \u2192 f x = f y"}
{"type": "\u2200 {n : \u2115} (i : fin n), \u21d1(fin_succ_equiv_last.symm) (option.some i) = \u21d1fin.cast_succ i"}
{"type": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : topological_space \u03b1] [_inst_2 : preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {a : \u03b1}, is_local_min f a \u2192 \u2200 (s : set \u03b1), is_local_min_on f s a"}
{"type": "\u2200 {\u03b1 : Type u} [_inst_1 : pseudo_metric_space \u03b1] (x : \u03b1), filter.comap (has_dist.dist x) filter.at_top \u2264 filter.cocompact \u03b1"}
{"type": "\u2200 {\u03b1 : Type u_1} {s : multiset \u03b1} {a : \u03b1}, a \u2208 s \u2192 (\u2203 (t : multiset \u03b1), s = a ::\u2098 t)"}
{"type": "\u2200\u1d50 (x : \u211d), \u00acliouville x"}
{"type": "\u2200 (f : circle_deg1_lift), filter.tendsto \u21d1f filter.at_top filter.at_top"}
{"type": "\u2200 {M : Type u_1} [_inst_1 : add_zero_class M] (a : M), add_commute a 0"}
{"type": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1} {b : \u03b2} {s : set \u03b1}, function.left_inverse g f \u2192 function.right_inverse g f \u2192 (b \u2208 f '' s \u2194 g b \u2208 s)"}
{"type": "\u2200 {J : Type v} {C : Type u} [_inst_1 : category_theory.category C] (B : C) (objs : J \u2192 C) (arrows : \u03a0 (j : J), objs j \u27f6 B) (X Y : category_theory.limits.wide_pullback_shape J) (f : X \u27f6 Y), (category_theory.limits.wide_pullback_shape.wide_cospan B objs arrows).map f = category_theory.limits.wide_pullback_shape.hom.cases_on f (\u03bb (f_1 : category_theory.limits.wide_pullback_shape J) (H_1 : X = f_1), eq.rec (\u03bb (H_2 : Y = X), eq.rec (\u03bb (f : X \u27f6 X) (H_3 : f == category_theory.limits.wide_pullback_shape.hom.id X), eq.rec (\ud835\udfd9 (option.cases_on X B objs)) _) _ f) H_1) (\u03bb (j : J) (H_1 : X = option.some j), eq.rec (\u03bb (f : option.some j \u27f6 Y) (H_2 : Y = option.none), eq.rec (\u03bb (f : option.some j \u27f6 option.none) (H_3 : f == category_theory.limits.wide_pullback_shape.hom.term j), eq.rec (arrows j) _) _ f) _ f) _ _ _"}
{"type": "\u2200 {\u03b1 : Type u_1} {l l' : filter \u03b1}, (l \u2293 l').ne_bot \u2194 \u2200 \u2983s : set \u03b1\u2984, s \u2208 l \u2192 \u2200 \u2983s' : set \u03b1\u2984, s' \u2208 l' \u2192 (s \u2229 s').nonempty"}
{"type": "\u2200 {\u03b1 : Type u_1} {m : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} {f : measure_theory.simple_func \u03b1 \u211d}, measure_theory.integrable \u21d1f \u03bc \u2192 0 \u2264\u1d50[\u03bc] \u21d1f \u2192 measure_theory.simple_func.integral \u03bc f = (\u222b\u207b (a : \u03b1), ennreal.of_real (\u21d1f a) \u2202\u03bc).to_real"}
{"type": "\u2200 {G : Type u} [_inst_1 : group G] (B : group_filter_basis G), (nhds 1).has_basis (\u03bb (V : set G), V \u2208 B) id"}
{"type": "\u2200 {\u03b1 : Sort u_1} [_inst_1 : subsingleton \u03b1] (x y : \u03b1), x = y \u2194 true"}
{"type": "\u2200 {G : Type u} [_inst_1 : add_group G] {b : G}, function.injective (\u03bb (a : G), b - a)"}
{"type": "\u2200 {X : Type u_2} [_inst_1 : emetric_space X] (m : set X \u2192 ennreal) (s : set X), filter.tendsto (\u03bb (n : \u2115), \u21d1(measure_theory.outer_measure.mk_metric'.pre m (\u2191n)\u207b\u00b9) s) filter.at_top (nhds (\u21d1(measure_theory.outer_measure.mk_metric' m) s))"}
{"type": "\u2200 {\u03b1 : Type u} (p : \u03b1 \u2192 Prop) [_inst_1 : decidable_pred p], list.filter_map (option.guard p) = list.filter p"}
{"type": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {F : Type u_3} [_inst_4 : normed_group F] [_inst_5 : normed_space \ud835\udd5c F] {s : set E} {f : E \u2192 F} {x : E} (m : fin 0 \u2192 E), \u21d1(iterated_fderiv_within \ud835\udd5c 0 f s x) m = f x"}
{"type": "\u2200 {\u03b1 : Sort u_1} {q : Prop} {p : \u03b1 \u2192 Prop}, (\u2200 (x : \u03b1), p x \u2228 q) \u2194 (\u2200 (x : \u03b1), p x) \u2228 q"}
{"type": "\u2200 {\u03b2 : Type u} {\u03b1 : Type v} [_inst_1 : comm_monoid \u03b2] (p : Prop) [_inst_2 : decidable p] (s t : finset \u03b1) (f : \u03b1 \u2192 \u03b2), (ite p s t).prod (\u03bb (x : \u03b1), f x) = ite p (s.prod (\u03bb (x : \u03b1), f x)) (t.prod (\u03bb (x : \u03b1), f x))"}
{"type": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {l : \u03b1 \u2192 \u03b2} {u : \u03b2 \u2192 \u03b1} [_inst_1 : preorder \u03b1] [_inst_2 : preorder \u03b2], galois_insertion l u \u2192 \u2200 {a b : \u03b2}, u a \u2264 u b \u2194 a \u2264 b"}
{"type": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : topological_space \u03b1] [_inst_2 : topological_space \u03b2] {s : set \u03b1} {t : set \u03b2} {f : \u03b1 \u2192 \u03b2} {a : \u03b1}, continuous f \u2192 a \u2208 closure s \u2192 (\u2200 (a : \u03b1), a \u2208 s \u2192 f a \u2208 t) \u2192 f a \u2208 closure t"}
{"type": "\u2200 {M : Type u_1} {N : Type u_2} [_inst_1 : add_zero_class M] [_inst_2 : add_zero_class N] (S : add_submonoid M) {f : M \u2192+ N}, add_submonoid.map f (add_submonoid.comap f (add_submonoid.map f S)) = add_submonoid.map f S"}
{"type": "\u2200 (z : \u21a5circle), \u21d1exp_map_circle \u2191z.arg = z"}
{"type": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] [_inst_2 : category_theory.non_preadditive_abelian C] {X Y : C} (f : X \u27f6 Y), (\u2200 (Z : C) (g : Z \u27f6 X), g \u226b f = 0 \u2192 g = 0) \u2192 category_theory.mono f"}
{"type": "\u2200 {\u03b1 : Type u_1} [_inst_1 : division_ring \u03b1] (a a' b b' c c' d : \u03b1), d \u2260 0 \u2192 a * d = a' \u2192 b * d = b' \u2192 c * d = c' \u2192 a' + b' = c' \u2192 a + b = c"}
{"type": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : preorder \u03b1] [_inst_2 : preorder \u03b2] {l : \u03b1 \u2192 \u03b2} {u : \u03b2 \u2192 \u03b1}, galois_connection l u \u2192 \u2200 {a : \u03b1}, is_glb {b : \u03b2 | a \u2264 u b} (l a)"}
{"type": "\u2200 {\u03b1 : Type u_1} {E : Type u_3} {F : Type u_4} [_inst_1 : has_norm E] [_inst_2 : has_norm F] (f : \u03b1 \u2192 E) (g : \u03b1 \u2192 F), asymptotics.is_o f g \u22a5"}
{"type": "\u2200 {\u03b1 : Type u_1} [_inst_1 : measurable_space \u03b1] {f : \u03b1 \u2192 \u211d}, measurable f \u2192 measurable (\u03bb (x : \u03b1), (f x).to_nnreal)"}
{"type": "\u2200 {\u03b1 : Type u} [_inst_1 : topological_space \u03b1] [_inst_2 : linear_order \u03b1] [_inst_3 : order_closed_topology \u03b1] {a : \u03b1}, is_open (set.Iio a)"}
{"type": "\u2200 {n : \u2115}, 1 = dihedral_group.r 0"}
{"type": "\u2200 {M : Type w} {M\u2082 : Type x} [_inst_1 : add_comm_group M] [_inst_2 : add_comm_group M\u2082] (f : M \u2192+ M\u2082) (x : \u2124) (a : M), \u21d1f (x \u2022 a) = x \u2022 \u21d1f a"}
{"type": "\u2200 {X : Type u} {Y : Type v} [_inst_1 : topological_space X] [_inst_2 : topological_space Y] {P : C(X, Y) \u2192 Prop} {f\u2080 f\u2081 g\u2080 g\u2081 : C(X, Y)} (F : f\u2080.homotopy_with f\u2081 P) (h\u2080 : f\u2080 = g\u2080) (h\u2081 : f\u2081 = g\u2081) (\u1fb0 : \u21a5unit_interval \u00d7 X), \u21d1(F.cast h\u2080 h\u2081) \u1fb0 = \u21d1F \u1fb0"}
{"type": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] [_inst_2 : category_theory.preadditive C] [_inst_3 : category_theory.has_shift C \u2124] [_inst_4 : \u2200 (n : \u2124), (category_theory.shift_functor C n).additive] (T : category_theory.triangulated.triangle C), (category_theory.triangulated.to_inv_rotate_rotate T).hom\u2081 = (category_theory.shift_shift_neg T.obj\u2081 1).inv"}
{"type": "\u2200 (\u03b1 : Type u_1) (\u03b2 : Type u_2) [_inst_1 : topological_space \u03b1] [_inst_2 : compact_space \u03b1] [_inst_3 : metric_space \u03b2], (continuous_map.isometric_bounded_of_compact \u03b1 \u03b2).to_equiv = continuous_map.equiv_bounded_of_compact \u03b1 \u03b2"}
{"type": "\u2200 {\u03b1 : Type u_1} {E : Type u_3} [_inst_1 : measurable_space \u03b1] [_inst_2 : measurable_space E] [_inst_3 : normed_group E] [_inst_4 : topological_space \u03b1] [_inst_5 : borel_space \u03b1] [_inst_6 : borel_space E] [_inst_7 : conditionally_complete_linear_order \u03b1] [_inst_8 : conditionally_complete_linear_order E] [_inst_9 : order_topology \u03b1] [_inst_10 : order_topology E] [_inst_11 : topological_space.second_countable_topology E] {\u03bc : measure_theory.measure \u03b1} [_inst_12 : measure_theory.is_locally_finite_measure \u03bc] {s : set \u03b1}, is_compact s \u2192 \u2200 {f : \u03b1 \u2192 E}, antitone f \u2192 measure_theory.integrable_on f s \u03bc"}
{"type": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {F : Type u_3} [_inst_4 : normed_group F] [_inst_5 : normed_space \ud835\udd5c F] {G : Type u_4} [_inst_6 : normed_group G] [_inst_7 : normed_space \ud835\udd5c G] {n : with_top \u2115} {g : F \u2192 G} {f : E \u2192 F} (x : E), times_cont_diff \ud835\udd5c n g \u2192 times_cont_diff_at \ud835\udd5c n f x \u2192 times_cont_diff_at \ud835\udd5c n (g \u2218 f) x"}
{"type": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] [_inst_2 : category_theory.monoidal_category C] {X\u2081 Y\u2081 X\u2082 Y\u2082 : category_theory.center C} (f : X\u2081 \u27f6 Y\u2081) (g : X\u2082 \u27f6 Y\u2082), (f \u2297 g).f = f.f \u2297 g.f"}
{"type": "\u2200 {R : Type u} [_inst_1 : comm_ring R] [_inst_2 : local_ring R] (a : R), a \u2208 nonunits R \u2192 is_unit (1 - a)"}
{"type": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : nonempty \u03b2], set.range prod.fst = set.univ"}
{"type": "\u2200 {\u03b1 : Type u_1} [_inst_1 : preorder \u03b1] [_inst_2 : locally_finite_order \u03b1] {a b : \u03b1}, \u00aca < b \u2192 finset.Ico a b = \u2205"}
{"type": "\u2200 {G\u2080 : Type u_1} [_inst_1 : group_with_zero G\u2080] {a : G\u2080}, a \u2260 0 \u2192 \u2200 (i : \u2124), a ^ (1 + i) = a * a ^ i"}
{"type": "\u2200 {\u03b1 : Type u_1} [_inst_1 : subsingleton \u03b1] (e : equiv.perm \u03b1), \u21d1e = id"}
{"type": "\u2200 {f : \u211d \u2192 \u211d} {f' x : \u211d}, has_strict_deriv_at f f' x \u2192 has_strict_deriv_at (\u03bb (x : \u211d), real.sin (f x)) (real.cos (f x) * f') x"}
{"type": "\u2200 {R : Type u_1} {\u0393\u2080 : Type u_2} [_inst_1 : linear_ordered_add_comm_monoid_with_top \u0393\u2080] [_inst_3 : ring R] (v : add_valuation R \u0393\u2080) {x y : R} {g : \u0393\u2080}, g \u2264 \u21d1v x \u2192 g \u2264 \u21d1v y \u2192 g \u2264 \u21d1v (x + y)"}
{"type": "\u2200 {\u03b1 : Type u} [_inst_1 : linear_order \u03b1] [_inst_2 : order_bot \u03b1] (a : \u03b1), linear_order.min \u22a5 a = \u22a5"}
{"type": "\u2200 {C : Type u} [_inst_2 : category_theory.category C] [_inst_3 : category_theory.limits.has_zero_morphisms C] {W X Y : C} [_inst_4 : category_theory.limits.has_binary_biproduct X Y] (f : W \u27f6 X) (g : W \u27f6 Y), category_theory.limits.biprod.lift f g \u226b category_theory.limits.biprod.fst = f"}
{"type": "\u2200 {\u03b1 : Type u} {x : filter \u03b1}, filter.tendsto id x x"}
{"type": "\u2200 {\u03b1 : Type u} [_inst_1 : conditionally_complete_linear_order \u03b1] [_inst_2 : topological_space \u03b1] [_inst_3 : order_topology \u03b1] [_inst_8 : densely_ordered \u03b1] {\u03b4 : Type u_1} [_inst_9 : linear_order \u03b4] [_inst_10 : topological_space \u03b4] [_inst_11 : order_closed_topology \u03b4] {a b : \u03b1}, a \u2264 b \u2192 \u2200 {f : \u03b1 \u2192 \u03b4}, continuous_on f (set.Icc a b) \u2192 set.Ioc (f a) (f b) \u2286 f '' set.Ioc a b"}
{"type": "\u2200 {G : Type u_7} [_inst_1 : add_group G] (a b : G), \u21d1(equiv.sub_left a) b = a - b"}
{"type": "\u2200 {R : Type u_4} [_inst_1 : linear_ordered_ring R] {a : R}, a \u2260 0 \u2192 \u2200 (n : \u2115), 0 < a ^ bit0 n"}
{"type": "\u2200 (k : \u2115), (primitive_roots k \u2102).card = k.totient"}
{"type": "\u2200 {\u03b1 : Type u_1} {\u03b9 : Type u_5} {m0 : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} [_inst_3 : encodable \u03b9] {s : \u03b9 \u2192 set \u03b1}, (\u2200 (i : \u03b9), measurable_set (s i)) \u2192 directed has_subset.subset s \u2192 \u2200 {t : set \u03b1}, measurable_set t \u2192 (\u21d1(\u03bc.restrict (\u22c3 (i : \u03b9), s i)) t = \u2a06 (i : \u03b9), \u21d1(\u03bc.restrict (s i)) t)"}
{"type": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] {X Y Z : C} (f : X \u27f6 Y) (g : X \u27f6 Z) [_inst_2 : category_theory.is_iso g], (category_theory.limits.pushout_cocone_of_right_iso f g).\u03b9.app category_theory.limits.walking_span.left = \ud835\udfd9 ((category_theory.limits.span f g).obj category_theory.limits.walking_span.left)"}
{"type": "\u2200 {\u03b1 : Type u_1} [_inst_1 : measurable_space \u03b1] [_inst_2 : topological_space \u03b1] {\u03bc : measure_theory.measure \u03b1} [_inst_3 : opens_measurable_space \u03b1] [_inst_4 : \u03bc.regular] \u2983A : set \u03b1\u2984, measurable_set A \u2192 \u21d1\u03bc A \u2260 \u22a4 \u2192 \u2200 {\u03b5 : ennreal}, \u03b5 \u2260 0 \u2192 (\u2203 (K : set \u03b1) (H : K \u2286 A), is_compact K \u2227 \u21d1\u03bc A < \u21d1\u03bc K + \u03b5)"}
{"type": "\u21911 = 1"}
{"type": "\u2200 {\u03b2 : Type u} {\u03b1 : Type v} {s : finset \u03b1} [_inst_1 : add_comm_monoid \u03b2] {p : \u03b1 \u2192 Prop} {hp : decidable_pred p} (f g : \u03b1 \u2192 \u03b2), (\u2200 (x : \u03b1), x \u2208 s \u2192 \u00acp x) \u2192 s.sum (\u03bb (x : \u03b1), ite (p x) (f x) (g x)) = s.sum (\u03bb (x : \u03b1), g x)"}
{"type": "\u2200 {R : Type u_1} [_inst_1 : comm_ring R] (c\u2081 c\u2082 : R) (v : R \u00d7 R), \u21d1(clifford_algebra_quaternion.Q c\u2081 c\u2082) v = c\u2081 * (v.fst * v.fst) + c\u2082 * (v.snd * v.snd)"}
{"type": "\u2200 {\u03b9 : Type u} {\u03b2\u2082 : \u03b9 \u2192 Type v\u2082} [_inst_3 : \u03a0 (i : \u03b9), add_zero_class (\u03b2\u2082 i)], dfinsupp.map_range.add_monoid_hom (\u03bb (i : \u03b9), add_monoid_hom.id (\u03b2\u2082 i)) = add_monoid_hom.id (\u03a0\u2080 (i : \u03b9), \u03b2\u2082 i)"}
{"type": "\u2200 {K : Type u} [_inst_1 : linear_ordered_field K] {a : K}, 0 \u2264 a \u2192 \u2200 (z : \u2124), 0 \u2264 a ^ z"}
{"type": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : cancel_comm_monoid_with_zero \u03b1] [_inst_2 : normalized_gcd_monoid \u03b1] {s : finset \u03b2} {f g : \u03b2 \u2192 \u03b1}, (\u2200 (b : \u03b2), b \u2208 s \u2192 f b \u2223 g b) \u2192 s.lcm f \u2223 s.lcm g"}
{"type": "\u2200 {\u03b1 : Type u_1} {E' : Type u_6} {F' : Type u_7} [_inst_4 : normed_group E'] [_inst_5 : normed_group F'] {f' : \u03b1 \u2192 E'} {g' : \u03b1 \u2192 F'} {l : filter \u03b1}, asymptotics.is_O (\u03bb (x : \u03b1), \u2225f' x\u2225) (\u03bb (x : \u03b1), \u2225g' x\u2225) l \u2194 asymptotics.is_O f' g' l"}
{"type": "\u2200 {\u03b1 : Type u_1} [_inst_1 : preorder \u03b1] [_inst_2 : locally_finite_order \u03b1] {a b c : \u03b1} [_inst_3 : decidable_pred (has_le.le c)], c \u2264 a \u2192 multiset.filter (\u03bb (x : \u03b1), c \u2264 x) (multiset.Ico a b) = multiset.Ico a b"}
{"type": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {\u03b3 : Type w} {f : filter \u03b1} {g : filter \u03b2} {h : filter \u03b3} {m\u2081 : \u03b1 \u2192 \u03b2} {m\u2082 : \u03b1 \u2192 \u03b3}, filter.tendsto m\u2081 f g \u2192 filter.tendsto m\u2082 f h \u2192 filter.tendsto (\u03bb (x : \u03b1), (m\u2081 x, m\u2082 x)) f (g.prod h)"}
{"type": "\u2200 {\u03b1 : Type u_1} (p : \u03b1 \u2192 Prop) [_inst_1 : decidable_pred p] (b : \u03b1) (s : multiset \u03b1), multiset.countp p (b ::\u2098 s) = multiset.countp p s + ite (p b) 1 0"}
{"type": "\u2200 {M : Type u_1} [_inst_1 : semi_normed_group M] (S : add_subgroup M) (m : M), \u2225\u2191m\u2225 \u2264 \u2225m\u2225"}
{"type": "\u2200 {G : Type u_1} \u2983g\u2081 g\u2082 : add_group G\u2984, add_group.add = add_group.add \u2192 g\u2081 = g\u2082"}
{"type": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} (f : \u03b1 \u2192 \u03b2) (s t : set \u03b1), f '' s \\ f '' t \u2286 f '' (s \\ t)"}
{"type": "\u2200 {X : Type u_1} {Y : Type u_2} [_inst_1 : topological_space X], locally_constant.map id = id"}
{"type": "\u2200 {\u03b1 : Type u_1} {m : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} (f : \u03b1 \u2192 ennreal), \u2200\u1d50 (y : \u03b1) \u2202\u03bc, f y \u2264 ess_sup f \u03bc"}
{"type": "\u2200 (n : \u2115), 0 < \u2191n + 1"}
{"type": "\u2200 {M : Type u_1} [_inst_1 : add_zero_class M] (S : add_submonoid M) (x y : \u21a5S), \u2191(x + y) = \u2191x + \u2191y"}
{"type": "\u2200 {\u03b1 : Type u} [t : topological_space \u03b1] [_inst_1 : topological_space.separable_space \u03b1] {\u03b9 : Type u_1} {s : \u03b9 \u2192 set \u03b1} {a : set \u03b9}, a.pairwise_disjoint s \u2192 (\u2200 (i : \u03b9), i \u2208 a \u2192 (interior (s i)).nonempty) \u2192 a.countable"}
{"type": "\u2200 {\u03b1 : Type u_1} [_inst_1 : decidable_eq \u03b1] {a b : \u03b1} {s : multiset \u03b1}, a \u2208 s.erase b \u2192 a \u2208 s"}
{"type": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : preorder \u03b2] {s : set \u03b1} {a : \u03b1} {b : \u03b2}, is_extr_on (\u03bb (_x : \u03b1), b) s a"}
{"type": "\u2200 {m : Type u_2} {\u03b1 : Type v} [_inst_1 : fintype m] [_inst_2 : non_unital_non_assoc_semiring \u03b1] (v : m \u2192 \u03b1), matrix.dot_product v 0 = 0"}
{"type": "measurable complex.sinh"}
{"type": "\u2200 {\u03b1 : Type u_1} [_inst_1 : decidable_eq \u03b1] (a : \u03b1), list.count a [a] = 1"}
{"type": "\u2200 {\u03b1 : Type u_1} [_inst_1 : emetric_space \u03b1] {K : nnreal} {f : \u03b1 \u2192 \u03b1}, contracting_with K f \u2192 1 - \u2191K \u2260 0"}
{"type": "\u2200 {C : Type v} [_inst_1 : category_theory.category C] [_inst_2 : category_theory.concrete_category C] {X Y : C} (f : X \u27f6 Y), function.injective \u21d1f \u2192 category_theory.mono f"}
{"type": "\u2200 {R : Type u_1} {M : Type u_2} [_inst_1 : ring R] [_inst_2 : add_comm_group M] [_inst_3 : module R M] (S : Type u_3) [_inst_4 : ring S] [_inst_5 : has_scalar S R] [_inst_6 : module S M] [_inst_7 : is_scalar_tower S R M] (P : submodule R M) (x : M), \u21d1(submodule.quotient.restrict_scalars_equiv S P) (submodule.quotient.mk x) = submodule.quotient.mk x"}
{"type": "\u2200 {k : Type u_1} {V : Type u_2} {P : Type u_3} [_inst_1 : ring k] [_inst_2 : add_comm_group V] [_inst_3 : module k V] [_inst_4 : add_torsor V P], function.injective coe"}
{"type": "\u2200 {\u03b1 \u03b2 : Type u} (f : \u03b2 \u2192 \u03b1 \u2192 \u03b2) (xs : free_monoid \u03b1) (a : \u03b2), mul_opposite.unop (monoid.foldl.of_free_monoid f xs) a = list.foldl f a xs"}
{"type": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] {W X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} [_inst_2 : category_theory.limits.has_pullback f g] (h : W \u27f6 X) (k : W \u27f6 Y) (w : h \u226b f = k \u226b g) {X' : C} (f' : Y \u27f6 X'), category_theory.limits.pullback.lift h k w \u226b category_theory.limits.pullback.snd \u226b f' = k \u226b f'"}
{"type": "\u2200 {R : Type u_1} {G : Type u_2} [_inst_1 : comm_ring R] [_inst_2 : is_domain R] [_inst_3 : group G] [_inst_4 : fintype G] (f : G \u2192* R), function.injective \u21d1f \u2192 is_cyclic G"}
{"type": "\u2200 {\u03b1 : Type u} [_inst_1 : pseudo_metric_space \u03b1] {x : \u03b1} {\u03b5 : \u211d}, metric.closed_ball x \u03b5 \\ metric.sphere x \u03b5 = metric.ball x \u03b5"}
{"type": "\u2200 (p : \u2115) [hp : fact (nat.prime p)] {R : Type u\u2081} [_inst_3 : comm_semiring R] [_inst_4 : char_p R p] [_inst_5 : perfect_ring R p] {S : Type u\u2082} [_inst_6 : comm_semiring S] [_inst_7 : char_p S p] {f g : R \u2192+* ring.perfection S p}, (\u2200 (x : R), \u21d1(perfection.coeff S p 0) (\u21d1f x) = \u21d1(perfection.coeff S p 0) (\u21d1g x)) \u2192 f = g"}
{"type": "deriv real.sin = real.cos"}
{"type": "\u2200 {R : Type u_3} {A : Type u_5} [_inst_1 : comm_ring R] [_inst_2 : comm_ring A] [_inst_5 : algebra R A] {\u03b9 : Type u_1} {s : set \u03b9} {f : \u03b9 \u2192 A}, set.inj_on f s \u2192 (algebraic_independent R (\u03bb (x : \u21a5s), f \u2191x) \u2194 algebraic_independent R (\u03bb (x : \u21a5(f '' s)), \u2191x))"}
{"type": "\u2200 (\u03b1 : Type u) [_inst_1 : group \u03b1] [_inst_2 : has_le \u03b1] [_inst_3 : covariant_class \u03b1 \u03b1 has_mul.mul has_le.le] [_inst_4 : covariant_class \u03b1 \u03b1 (function.swap has_mul.mul) has_le.le] (\u1fb0 : order_dual \u03b1), \u21d1(rel_iso.symm (order_iso.inv \u03b1)) \u1fb0 = (\u21d1order_dual.of_dual \u1fb0)\u207b\u00b9"}
{"type": "\u2200 {\u03b1 : Type u_1} (f : \u2115 \u2192 set \u03b1) (n : \u2115), disjointed f n \u2286 f n"}
{"type": "\u2200 {\u03b1 : Type u} [_inst_1 : uniform_space \u03b1] [_inst_4 : separated_space \u03b1] {x y : \u03b1}, cluster_pt (x, y) (uniformity \u03b1) \u2192 x = y"}
{"type": "\u2200 {\u03b1 : Type u_1} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [_inst_1 : is_well_order \u03b1 r] {x x' : \u03b1}, ordinal.typein r x \u2264 ordinal.typein r x' \u2194 \u00acr x' x"}
{"type": "\u2200 {\u03b1 : Type u} {p : set \u03b1 \u2192 Prop}, (\u2203 (s : set \u03b1), s.finite \u2227 p s) \u2194 \u2203 (s : finset \u03b1), p \u2191s"}
{"type": "\u2200 {R : Type u} [_inst_1 : euclidean_domain R] [_inst_2 : decidable_eq R] {a b c : R}, c \u2223 a \u2192 c \u2223 b \u2192 c \u2223 euclidean_domain.gcd a b"}
{"type": "\u2200 {X : Type u_1} {x : alexandroff X}, x \u2209 set.range coe \u2194 x = alexandroff.infty"}
{"type": "\u2200 {\u03b1 : Type u_1} {l : ordnode \u03b1} {x : \u03b1} {m : ordnode \u03b1} {y : \u03b1} {r : ordnode \u03b1}, l.sized \u2192 m.sized \u2192 r.sized \u2192 (l.node4_l x m y r).sized"}
{"type": "\u2200 {R : Type u} [_inst_1 : comm_semiring R] {A : Type v} [_inst_2 : semiring A] [_inst_3 : algebra R A] {M N : submodule R A} {C : A \u2192 Prop} {r : A}, r \u2208 M * N \u2192 (\u2200 (m : A), m \u2208 M \u2192 \u2200 (n : A), n \u2208 N \u2192 C (m * n)) \u2192 C 0 \u2192 (\u2200 (x y : A), C x \u2192 C y \u2192 C (x + y)) \u2192 (\u2200 (r : R) (x : A), C x \u2192 C (r \u2022 x)) \u2192 C r"}
{"type": "\u2200 {\u03b1 : Type u_1} {F : Type u_3} [_inst_3 : normed_group F] [_inst_4 : normed_space \u211d F] {m : measurable_space \u03b1} (\u03bc : measure_theory.measure \u03b1) (f : measure_theory.simple_func \u03b1 F), measure_theory.simple_func.integral \u03bc f = measure_theory.simple_func.set_to_simple_func (measure_theory.weighted_smul \u03bc) f"}
{"type": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {\u03b3 : Type u_3} {f : \u03b1 \u2192 \u03b2} {c : \u03b1} [_inst_1 : add_comm_monoid \u03b1] [_inst_2 : division_ring \u03b3] [_inst_3 : module \u03b3 \u03b1], function.periodic f c \u2192 \u2200 (a : \u03b3), function.periodic (\u03bb (x : \u03b1), f (a\u207b\u00b9 \u2022 x)) (a \u2022 c)"}
{"type": "\u2200 {\u03b1 : Type u_1} {C : set \u03b1 \u2192 Prop} {s : set (set \u03b1)} [m : measurable_space \u03b1], m = measurable_space.generate_from s \u2192 is_pi_system s \u2192 C \u2205 \u2192 (\u2200 (t : set \u03b1), t \u2208 s \u2192 C t) \u2192 (\u2200 (t : set \u03b1), measurable_set t \u2192 C t \u2192 C t\u1d9c) \u2192 (\u2200 (f : \u2115 \u2192 set \u03b1), pairwise (disjoint on f) \u2192 (\u2200 (i : \u2115), measurable_set (f i)) \u2192 (\u2200 (i : \u2115), C (f i)) \u2192 C (\u22c3 (i : \u2115), f i)) \u2192 \u2200 \u2983t : set \u03b1\u2984, measurable_set t \u2192 C t"}
{"type": "strict_mono coe"}
{"type": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} {M : Type w} [_inst_1 : linear_ordered_cancel_add_comm_monoid M] [_inst_2 : decidable_eq \u03b2] {s : finset \u03b1} {t : finset \u03b2} {f : \u03b1 \u2192 \u03b2} {w : \u03b1 \u2192 M} {b : M}, (\u2200 (a : \u03b1), a \u2208 s \u2192 f a \u2208 t) \u2192 t.nonempty \u2192 s.sum (\u03bb (x : \u03b1), w x) \u2264 t.card \u2022 b \u2192 (\u2203 (y : \u03b2) (H : y \u2208 t), (finset.filter (\u03bb (x : \u03b1), f x = y) s).sum (\u03bb (x : \u03b1), w x) \u2264 b)"}
{"type": "\u2200 {V : Type u_1} {P : Type u_2} [_inst_1 : inner_product_space \u211d V] [_inst_2 : metric_space P] [_inst_3 : normed_add_torsor V P] (s : affine_subspace \u211d P) [_inst_4 : nonempty \u21a5s] [_inst_5 : complete_space \u21a5(s.direction)], function.involutive \u21d1(euclidean_geometry.reflection s)"}
{"type": "\u2200 {M : Type u_1} [_inst_1 : comm_monoid M] {S : submonoid M} {N : Type u_2} [_inst_2 : comm_monoid N] {P : Type u_3} [_inst_3 : comm_monoid P] (f : S.localization_map N) {k : N \u2243* P}, (f.of_mul_equiv_of_localizations k).to_map = k.to_monoid_hom.comp f.to_map"}
{"type": "\u2200 {R : Type u_1} [_inst_1 : ring R] {E : Type u_2} [_inst_2 : add_comm_group E] [_inst_3 : module R E] {F : Type u_3} [_inst_4 : add_comm_group F] [_inst_5 : module R F] {G : Type u_4} [_inst_6 : add_comm_group G] [_inst_7 : module R G] (g : F \u2192\u2097[R] G) (f : linear_pmap R E F) (x : \u21a5((g.comp_pmap f).domain)), \u21d1(g.comp_pmap f) x = \u21d1g (\u21d1f x)"}
{"type": "\u2200 {G : Type u_1} {H : Type u_2} [_inst_1 : group G] [_inst_2 : group H] {f : G \u2192 H}, is_group_hom f \u2192 \u2200 (a b : G), f a = f b \u2194 a * b\u207b\u00b9 \u2208 is_group_hom.ker f"}
{"type": "\u2200 {n : \u2115} (a : fin n), \u21d1fin.cast_succ a < fin.last n"}
{"type": "\u2200 {n : \u2115} {\u03b1 : typevec (n + 1)} {\u03b1' : typevec (n + 1)} {f f' : \u03b1.drop.arrow \u03b1'.drop} {g g' : \u03b1.last \u2192 \u03b1'.last}, typevec.split_fun f g = typevec.split_fun f' g' \u2192 f = f' \u2227 g = g'"}
{"type": "\u2200 {f f' : \u211d \u2192 \u211d} {\u03b4 K \u03b5 a b : \u211d}, continuous_on f (set.Icc a b) \u2192 (\u2200 (x : \u211d), x \u2208 set.Ico a b \u2192 \u2200 (r : \u211d), f' x < r \u2192 (\u2203\u1da0 (z : \u211d) in nhds_within x (set.Ioi x), (z - x)\u207b\u00b9 * (f z - f x) < r)) \u2192 f a \u2264 \u03b4 \u2192 (\u2200 (x : \u211d), x \u2208 set.Ico a b \u2192 f' x \u2264 K * f x + \u03b5) \u2192 \u2200 (x : \u211d), x \u2208 set.Icc a b \u2192 f x \u2264 gronwall_bound \u03b4 K \u03b5 (x - a)"}
{"type": "\u2200 {\u03b1 : Type u} [_inst_1 : group \u03b1] [_inst_2 : has_lt \u03b1] [_inst_3 : covariant_class \u03b1 \u03b1 has_mul.mul has_lt.lt] {a b c : \u03b1}, b\u207b\u00b9 * a < c \u2192 a < b * c"}
{"type": "\u2200 {X : Type u} {Y : Type v} [_inst_1 : topological_space X] [_inst_2 : topological_space Y] {P : C(X, Y) \u2192 Prop} {f\u2080 f\u2081 : C(X, Y)} (F : f\u2080.homotopy_with f\u2081 P), F.symm.to_homotopy = F.to_homotopy.symm"}
{"type": "\u2200 {\u03b1 : Type u} [_inst_1 : partial_order \u03b1] {a b : \u03b1}, set.Icc a b \\ {a} = set.Ioc a b"}
{"type": "\u2200 {\u03b1 : Type u} [_inst_1 : add_monoid \u03b1] {f g : filter \u03b1} {s t : set \u03b1}, s \u2208 f \u2192 t \u2208 g \u2192 s + t \u2208 f + g"}
{"type": "\u2200 {R : Type u} [_inst_1 : comm_ring R] {I J : ideal R}, I.is_local \u2192 I \u2264 J \u2192 J \u2260 \u22a4 \u2192 J \u2264 I.jacobson"}
{"type": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} [_inst_1 : is_trichotomous \u03b1 r] [_inst_2 : is_irrefl \u03b2 s] (f : r \u2192r s), function.injective \u21d1f"}
{"type": "\u2200 {R : Type u_1} [_inst_1 : semiring R] (f : ring_invo R) (x : R), mul_opposite.unop (\u21d1f (mul_opposite.unop (\u21d1f x))) = x"}
{"type": "\u2200 (a b : \u2124), \u2191((rat.mk a b).denom) \u2223 b"}
{"type": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] (X : C) (Y Y' : C\u1d52\u1d56) (f : Y \u27f6 Y') (g : opposite.unop Y \u27f6 X), (category_theory.yoneda.obj X).map f g = f.unop \u226b g"}
{"type": "\u2200 {R : Type u_1} (A : Type u_2) {B : Type u_3} [_inst_1 : comm_ring R] [_inst_2 : comm_ring A] [_inst_3 : comm_ring B] [_inst_4 : algebra R B] [_inst_5 : algebra A B] [_inst_6 : is_integral_closure A R B] (x : B) (hx : is_integral R x), \u21d1(algebra_map A B) (is_integral_closure.mk' A x hx) = x"}
{"type": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {s : finset \u03b1} {t : finset \u03b2} {p : \u03b1 \u00d7 \u03b2}, p \u2208 s.product t \u2194 p.fst \u2208 s \u2227 p.snd \u2208 t"}
{"type": "\u2200 {\u03b1 : Type u} [_inst_1 : lattice \u03b1] [_inst_2 : comm_group \u03b1] (a : \u03b1), a\u207b\u00b9 \u2264 |a|"}
{"type": "\u2200 {\u03b1 : Type u} (f : equiv.perm \u03b1) {p : \u03b1 \u2192 Prop} [_inst_1 : fintype {x // p x}] (h : \u2200 (x : \u03b1), p x \u2192 p (\u21d1f x)) (x : {x // p x}), \u21d1(f.subtype_perm_of_fintype h) x = \u27e8\u21d1f \u2191x, _\u27e9"}
{"type": "\u2200 {V : Type u} (G : simple_graph V) {a : V} {e : \u21a5(G.edge_set)}, \u2191e \u2208 G.incidence_set a \u2194 a \u2208 \u2191e"}
{"type": "\u2200 {G : Type u_1} [_inst_1 : add_group G] [_inst_2 : topological_space G] {U V : open_add_subgroup G}, \u2191U \u2286 \u2191V \u2194 U \u2264 V"}
{"type": "\u2200 {a : ennreal}, a + \u22a4 = \u22a4"}
{"type": "\u2200 {\u03b1 : Sort u} {\u03b2 : Sort v} (P : \u03b1 \u2192 Sort w) (e : \u03b1 \u2243 \u03b2) (f : \u03a0 (b : \u03b2), P (\u21d1(e.symm) b)) (x : \u03b1), \u21d1((equiv.Pi_congr_left' P e).symm) f x = _.mpr (f (\u21d1e x))"}
{"type": "\u2200 {U : Type u_1} [_inst_1 : quiver U] {V : Type u_3} [_inst_2 : quiver V] {W : Type u_5} [_inst_3 : quiver W] (F : prefunctor U V) (G : prefunctor V W) (X Y : U) (f : X \u27f6 Y), (F.comp G).map f = G.map (F.map f)"}
{"type": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {D : Type u\u2082} [_inst_2 : category_theory.category D] {J : Type u} [_inst_3 : category_theory.category J] (E : C \u2964 D) [_inst_4 : category_theory.is_equivalence E] [_inst_5 : category_theory.limits.has_colimits_of_shape J D], category_theory.limits.has_colimits_of_shape J C"}
{"type": "\u2200 {\u03b1 : Type u_1} {l : list \u03b1} {x : \u03b1}, list.duplicate x l \u2192 l \u2260 list.nil"}
{"type": "\u2200 {R : Type u_1} [_inst_1 : normed_ring R] [_inst_2 : complete_space R] (k : \u2115) {r : R}, \u2225r\u2225 < 1 \u2192 summable (\u03bb (n : \u2115), \u2191n ^ k * r ^ n)"}
{"type": "times_cont_mdiff (model_with_corners_self \u211d \u211d) (model_with_corners_self \u211d (euclidean_space \u211d (fin 1))) \u22a4 \u21d1exp_map_circle"}
{"type": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] (X : category_theory.cosimplicial_object.augmented C\u1d52\u1d56) (X_1 : simplex_category), X.left_op_right_op_iso.hom.right.app X_1 = \ud835\udfd9 (X.right.obj X_1)"}
{"type": "\u2200 {M : Type u_1} {N : Type u_2} [_inst_1 : monoid M] [_inst_2 : monoid N] {s : set M} (f : M \u2192 N) (hs : submonoid.closure s = \u22a4) (h1 : f 1 = 1) (hmul : \u2200 (x y : M), y \u2208 s \u2192 f (x * y) = f x * f y), \u21d1(monoid_hom.of_mdense f hs h1 hmul) = f"}
{"type": "\u2200 {M : Type u_1} {N : Type u_2} [_inst_1 : monoid N] [_inst_2 : has_scalar M N] [_inst_3 : is_scalar_tower M N N] (x : M) (y : N), x \u2022 1 * y = x \u2022 y"}
{"type": "\u2200 {A : Type u_1} {\u03b9 : Type u_2} [_inst_1 : ring A] [_inst_2 : nonempty \u03b9] {B : \u03b9 \u2192 add_subgroup A} (hB : ring_subgroups_basis B) {V : set A}, V \u2208 ring_filter_basis.to_add_group_filter_basis \u2194 \u2203 (i : \u03b9), V = \u2191(B i)"}
{"type": "\u2200 {K : Type u} [_inst_1 : field K] (s : subfield K) (m : multiset K), (\u2200 (a : K), a \u2208 m \u2192 a \u2208 s) \u2192 m.sum \u2208 s"}
{"type": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} (e : r \u2243r s), set.range \u21d1e = set.univ"}
{"type": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {m : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} [_inst_1 : normed_group \u03b2] {f g : \u03b1 \u2192 \u03b2}, measure_theory.has_finite_integral f \u03bc \u2192 f =\u1d50[\u03bc] g \u2192 measure_theory.has_finite_integral g \u03bc"}
{"type": "\u2200 {\u03b9 : Type u_9} {R : Type u_10} {R\u2082 : Type u_11} {M : Type u_12} {M\u2082 : Type u_13} [_inst_15 : semiring R] [_inst_16 : semiring R\u2082] [_inst_17 : add_comm_monoid M] [_inst_18 : module R M] [_inst_19 : add_comm_monoid M\u2082] [_inst_20 : module R\u2082 M\u2082] [_inst_21 : topological_space M] [_inst_22 : topological_space M\u2082] {\u03c3 : R \u2192+* R\u2082} {f : \u03b9 \u2192 M} (\u03c6 : M \u2192SL[\u03c3] M\u2082), summable f \u2192 summable (\u03bb (b : \u03b9), \u21d1\u03c6 (f b))"}
{"type": "\u2200 {G : Type u} [_inst_1 : group G] (c : G), function.left_inverse (\u03bb (x : G), c\u207b\u00b9 * x) (\u03bb (x : G), c * x)"}
{"type": "\u2200 {o : ordinal}, o.pred.succ = o \u2194 \u2203 (a : ordinal), o = a.succ"}
{"type": "\u2200 {\u03b1 : Type u_1} {E : Type u_3} {F : Type u_4} [_inst_1 : has_norm E] [_inst_2 : has_norm F] {f : \u03b1 \u2192 E} {g : \u03b1 \u2192 F} {l : filter \u03b1}, (\u2200 \u2983c : \u211d\u2984, 0 < c \u2192 (\u2200\u1da0 (x : \u03b1) in l, \u2225f x\u2225 \u2264 c * \u2225g x\u2225)) \u2192 asymptotics.is_o f g l"}
{"type": "\u2200 {\u03b1 : Sort u_1} (y : \u03b1) (p : \u03b1 \u2192 Prop), \u2203 (x : \u03b1), x = y \u2228 p x"}
{"type": "\u2200 {R : Type u_1} {M : Type u_9} [_inst_1 : semiring R] [_inst_5 : add_comm_monoid M] [_inst_10 : module R M] (n : \u2115), linear_map.id ^ n = linear_map.id"}
{"type": "\u2200 {X : Type u_1} [_inst_1 : topological_space X] {A B : discrete_quotient X} (h : A \u2264 B) (x : X), discrete_quotient.of_le h (A.proj x) = B.proj x"}
{"type": "set.inj_on int.nat_abs (set.Iic 0)"}
{"type": "\u2200 {\u03b9 : Type u_1} {I : box_integral.box \u03b9} [_inst_1 : fintype \u03b9] {\u03c0\u2081 \u03c0\u2082 : box_integral.prepartition I}, \u03c0\u2081.Union = \u03c0\u2082.Union \u2192 \u03c0\u2081.compl = \u03c0\u2082.compl"}
{"type": "\u2200 {\u03b1 : Type u_1} [_inst_1 : preorder \u03b1] [_inst_2 : succ_order \u03b1] [_inst_3 : is_succ_archimedean \u03b1] {a b : \u03b1}, (\u2203 (n : \u2115), succ_order.succ^[n] a = b) \u2194 a \u2264 b"}
{"type": "\u2200 {\ud835\udd5c : Type u_1} {E : Type u_2} [_inst_1 : ordered_ring \ud835\udd5c] [_inst_2 : add_comm_group E] [_inst_3 : module \ud835\udd5c E] {K : geometry.simplicial_complex \ud835\udd5c E} {x : E}, x \u2208 K.vertices \u2194 {x} \u2208 K.faces"}
{"type": "\u2200 {\u03b1 : Type u_1} {f : filter \u03b1} {p : \u03b1 \u2192 Prop}, (\u2200\u1da0 (s : set \u03b1) in f.lift' set.powerset, \u2200 (x : \u03b1), x \u2208 s \u2192 p x) \u2192 (\u2200\u1da0 (x : \u03b1) in f, p x)"}
{"type": "\u2200 {J : Type u\u2081} [_inst_1 : category_theory.category J] {C : Type u\u2083} [_inst_3 : category_theory.category C] {F : J \u2964 C} (A B : category_theory.limits.cone F), (A \u27f6 B) = category_theory.limits.cone_morphism A B"}
{"type": "\u2200 {\u03b9 : Type u_1} {\u03b1 : \u03b9 \u2192 Type u_3} [_inst_1 : fintype \u03b9] {m : \u03a0 (i : \u03b9), measure_theory.outer_measure (\u03b1 i)} {s : \u03a0 (i : \u03b9), set (\u03b1 i)}, (set.univ.pi s).nonempty \u2192 measure_theory.pi_premeasure m (set.univ.pi s) = finset.univ.prod (\u03bb (i : \u03b9), \u21d1(m i) (s i))"}
{"type": "\u2200 {r p : \u211d}, 0 \u2264 r \u2192 (r.to_nnreal < p.to_nnreal \u2194 r < p)"}
{"type": "function.periodic complex.cos (2 * \u2191real.pi)"}
{"type": "\u2200 {\u03b9 : Type u_1} {V : Type u} [_inst_1 : category_theory.category V] [_inst_2 : category_theory.limits.has_zero_morphisms V] {c : complex_shape \u03b9} (C : homological_complex V c) [_inst_3 : category_theory.limits.has_zero_object V] {i j : \u03b9} (r : c.rel i j) {X' : V} (f' : C.X j \u27f6 X'), (C.X_prev_iso r).inv \u226b C.d_to j \u226b f' = C.d i j \u226b f'"}
{"type": "\u2200 {\u03b1 : Type u} [_inst_1 : linear_order \u03b1] {a b c : \u03b1}, c < a \u2192 c \u2209 set.Icc a b"}
{"type": "\u2200 {\u03b1 : Type u} [_inst_1 : uniform_space \u03b1] {f : filter \u03b1} (hf : cauchy f) {U : \u2115 \u2192 set (\u03b1 \u00d7 \u03b1)} (U_mem : \u2200 (n : \u2115), U n \u2208 uniformity \u03b1), (\u2200 (s : set (\u03b1 \u00d7 \u03b1)), s \u2208 uniformity \u03b1 \u2192 (\u2203 (n : \u2115), U n \u2286 s)) \u2192 cauchy_seq (sequentially_complete.seq hf U_mem)"}
{"type": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : preorder \u03b1] [_inst_2 : preorder \u03b2] {f g : \u03b1 \u2192 \u03b2}, antitone f \u2192 monotone g \u2192 monotone (\u03bb (x : \u03b1), set.Ico (f x) (g x))"}
{"type": "\u2200 (z : upper_half_plane), \u2191z.re = z.re"}
{"type": "\u2200 {R : Type u} [_inst_1 : semiring R] {p q : polynomial R}, q.monic \u2192 p.degree < q.degree \u2192 (p + q).monic"}
{"type": "\u2200 (R : Type u) (A : Type v) [_inst_1 : comm_semiring R] [_inst_2 : semiring A] [_inst_4 : algebra R A], algebra.adjoin R set.univ = \u22a4"}
{"type": "\u2200 {E : Type u_1} [_inst_1 : normed_group E] [_inst_2 : normed_space \u211d E] {f g : E \u2192 \u211d} {x : E} {s : set E} {n : with_top \u2115}, times_cont_diff_within_at \u211d n f s x \u2192 times_cont_diff_within_at \u211d n g s x \u2192 f x \u2260 0 \u2192 times_cont_diff_within_at \u211d n (\u03bb (x : E), f x ^ g x) s x"}
{"type": "\u2200 {\u03b1 : Type u_1} [_inst_1 : decidable_eq \u03b1] [_inst_2 : fintype \u03b1] (\u03c3 : equiv.perm \u03b1) (n : \u2115), (\u03c3 ^ n).support \u2264 \u03c3.support"}
{"type": "\u2200 {\u03b1 : Type u} [_inst_1 : add_monoid \u03b1] (f : filter \u03b1), 0 + f = f"}
{"type": "\u2200 {\u03b1 : Type u_1} {E : Type u_2} [_inst_1 : normed_group E] [_inst_2 : measurable_space E] {m : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} [_inst_10 : normed_space \u211d E] {f g : measure_theory.simple_func \u03b1 E}, measure_theory.integrable \u21d1f \u03bc \u2192 measure_theory.integrable \u21d1g \u03bc \u2192 measure_theory.simple_func.integral \u03bc (f - g) = measure_theory.simple_func.integral \u03bc f - measure_theory.simple_func.integral \u03bc g"}
{"type": "\u2200 {\u03b1 : Type u} {lt : \u03b1 \u2192 \u03b1 \u2192 Prop} {t : rbnode \u03b1}, rbnode.well_formed lt t \u2192 (\u2203 (c : rbnode.color) (n : \u2115), t.is_red_black c n)"}
{"type": "\u2200 {\u03b1 : Type u_1} {f : \u03b1 \u2192 \u03b1} {x : \u03b1} {g : \u03b1 \u2192 \u03b1}, function.commute f g \u2192 function.minimal_period (f \u2218 g) x \u2223 function.minimal_period f x * function.minimal_period g x"}
{"type": "\u2200 (x : punit), -x = punit.star"}
{"type": "\u2200 {\u03b1 : Type u_1} (l : ordnode \u03b1) (x : \u03b1) (r : ordnode \u03b1), (l.rotate_r x r).dual = r.dual.rotate_l x l.dual"}
{"type": "\u2200 {R : Type u\u2081} [_inst_5 : ring R] (r : R \u2192 R \u2192 Prop) {a b : R}, {to_quot := quot.mk (ring_quot.rel r) a} - {to_quot := quot.mk (ring_quot.rel r) b} = {to_quot := quot.mk (ring_quot.rel r) (a - b)}"}
{"type": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_3 : topological_space \u03b1] [_inst_4 : normed_group \u03b2] (f : \u03b1 \u2192 \u03b2) (Hf : continuous f) (C : \u211d) (H : \u2200 (x : \u03b1), \u2225f x\u2225 \u2264 C), \u21d1(bounded_continuous_function.of_normed_group f Hf C H) = f"}
{"type": "\u2200 (G : Type u_1) [_inst_1 : comm_group_with_zero G], (mul_equiv.inv\u2080 G).symm = mul_equiv.inv\u2080 G"}
{"type": "\u2200 {A : Type u_1} {\u03b9 : Type u_2} [_inst_1 : ring A] [_inst_2 : nonempty \u03b9] {B : \u03b9 \u2192 add_subgroup A} (hB : ring_subgroups_basis B) (i : \u03b9), \u2191(B i) \u2208 ring_filter_basis.to_add_group_filter_basis"}
{"type": "\u2200 {R\u2081 : Type u_1} {R\u2082 : Type u_2} {R\u2083 : Type u_3} [_inst_1 : semiring R\u2081] [_inst_2 : semiring R\u2082] [_inst_3 : semiring R\u2083] {\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082} {\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083} {\u03c3\u2081\u2083 : R\u2081 \u2192+* R\u2083} [_inst_4 : ring_hom_comp_triple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083] [_inst_5 : ring_hom_surjective \u03c3\u2081\u2082] [_inst_6 : ring_hom_surjective \u03c3\u2082\u2083], ring_hom_surjective \u03c3\u2081\u2083"}
{"type": "\u2200 {S : Type u_1} [_inst_1 : ordered_semiring S] {R : Type u_2} [_inst_2 : semiring R] (abv : R \u2192 S) [_inst_3 : is_absolute_value abv], abv 0 = 0"}
{"type": "\u2200 {C : Type u} [_inst_1 : category_theory.category C], (\u03a0 {X Y : C} (f : X \u27f6 Y), category_theory.limits.strong_epi_mono_factorisation f) \u2192 category_theory.limits.has_strong_epi_mono_factorisations C"}
{"type": "\u2200 {\u03b1 : Type u_1} (m\u2081 m\u2082 : measure_theory.outer_measure \u03b1) (s : set \u03b1), \u21d1(m\u2081 + m\u2082) s = \u21d1m\u2081 s + \u21d1m\u2082 s"}
{"type": "\u2200 (R : Type u) {X : Type v} [_inst_1 : semiring R] {A : Type w} [_inst_2 : non_unital_non_assoc_semiring A] [_inst_3 : module R A] [_inst_4 : is_scalar_tower R A A] [_inst_5 : smul_comm_class R A A] (F : non_unital_alg_hom R (free_non_unital_non_assoc_algebra R X) A), \u21d1((free_non_unital_non_assoc_algebra.lift R).symm) F = \u21d1F \u2218 free_non_unital_non_assoc_algebra.of R"}
{"type": "\u2200 {\u03b1 : Type u} [_inst_1 : add_group \u03b1] [_inst_2 : has_le \u03b1] [_inst_3 : covariant_class \u03b1 \u03b1 has_add.add has_le.le] {a : \u03b1}, 0 \u2264 -a \u2194 a \u2264 0"}
{"type": "\u2200 {\u03b1 : Type u} {a b : \u03b1} [_inst_1 : comm_monoid \u03b1], b \u2208 nonunits \u03b1 \u2192 a * b \u2208 nonunits \u03b1"}
{"type": "\u2200 {\u03b1 : Type u} (l\u2081 : list \u03b1) (a : \u03b1) (l\u2082 : list \u03b1), (l\u2081 ++ a :: l\u2082).last' = (a :: l\u2082).last'"}
{"type": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] {X Y : C} [_inst_2 : category_theory.limits.has_binary_product X Y], category_theory.limits.prod.map (\ud835\udfd9 X) (\ud835\udfd9 Y) = \ud835\udfd9 (X \u2a2f Y)"}
{"type": "\u2200 {\u03b1 : Type u_1} {M : Type u_4} {N : Type u_5} [_inst_1 : add_comm_monoid M] [_inst_2 : add_comm_monoid N] {s : set \u03b1} (f : \u03b1 \u2192 M) (g : M \u2192+ N), s.finite \u2192 \u21d1g (finsum (\u03bb (j : \u03b1), finsum (\u03bb (H : j \u2208 s), f j))) = finsum (\u03bb (i : \u03b1), finsum (\u03bb (H : i \u2208 s), \u21d1g (f i)))"}
{"type": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : topological_space \u03b1] [_inst_2 : topological_space \u03b2] {f : \u03b1 \u2192 \u03b2}, continuous f \u2192 \u2200 (x : \u03b1), filter.tendsto f (nhds x) (nhds (f x))"}
{"type": "\u2200 {C : Type u} [_inst_2 : category_theory.category C] (_x _x_1 : category_theory.comma (\ud835\udfed C) (\ud835\udfed C)) (f : _x \u27f6 _x_1), category_theory.arrow.right_func.map f = f.right"}
{"type": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {\u03b3 : Type u_3} [_inst_1 : has_mul \u03b3] (f : \u03b1 \u2192 \u03b2) (g\u2081 g\u2082 : \u03b1 \u2192 \u03b3) (e\u2081 e\u2082 : \u03b2 \u2192 \u03b3), function.extend f (g\u2081 * g\u2082) (e\u2081 * e\u2082) = function.extend f g\u2081 e\u2081 * function.extend f g\u2082 e\u2082"}
{"type": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {m : measurable_space \u03b1} {\u03bc : measure_theory.measure \u03b1} {x : \u03b2} {t : set \u03b2} {s : set \u03b1}, \u21d1\u03bc (ite (x \u2208 t) s \u2205) = t.indicator (\u03bb (_x : \u03b2), \u21d1\u03bc s) x"}
{"type": "\u2200 {\ud835\udd5c : Type u_1} {E : Type u_2} {\u03b2 : Type u_4} [_inst_1 : ordered_semiring \ud835\udd5c] [_inst_2 : add_comm_monoid E] [_inst_4 : ordered_add_comm_monoid \u03b2] [_inst_5 : has_scalar \ud835\udd5c E] [_inst_6 : has_scalar \ud835\udd5c \u03b2] {s : set E} {f : E \u2192 \u03b2} {t : set E}, strict_concave_on \ud835\udd5c t f \u2192 s \u2286 t \u2192 convex \ud835\udd5c s \u2192 strict_concave_on \ud835\udd5c s f"}
{"type": "\u2200 {x y z : \u211d}, 0 \u2264 x \u2192 x \u2264 y \u2192 0 \u2264 z \u2192 x ^ z \u2264 y ^ z"}
{"type": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} (bs : list \u03b2), list.nil.zip_right bs = list.map (\u03bb (b : \u03b2), (option.none \u03b1, b)) bs"}
{"type": "real.tanh 0 = 0"}
{"type": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_4 : has_add \u03b1] [_inst_5 : add_comm_group \u03b2] {f : \u03b1 \u2192 \u03b2}, is_add_hom f \u2192 is_add_hom (\u03bb (a : \u03b1), -f a)"}
{"type": "continuous complex.sinh"}
{"type": "\u2200 {V\u2081 : Type u_3} {V\u2082 : Type u_4} [_inst_3 : semi_normed_group V\u2081] [_inst_4 : semi_normed_group V\u2082] {W\u2081 : Type u_6} {W\u2082 : Type u_7} [_inst_6 : semi_normed_group W\u2081] [_inst_7 : semi_normed_group W\u2082] {f\u2081 g\u2081 : normed_group_hom V\u2081 W\u2081} {f\u2082 g\u2082 : normed_group_hom V\u2082 W\u2082} {\u03c6 : normed_group_hom V\u2081 V\u2082} {\u03c8 : normed_group_hom W\u2081 W\u2082} (hf : \u03c8.comp f\u2081 = f\u2082.comp \u03c6) (hg : \u03c8.comp g\u2081 = g\u2082.comp \u03c6) (C : \u211d), \u2225\u03c6.comp (normed_group_hom.equalizer.\u03b9 f\u2081 g\u2081)\u2225 \u2264 C \u2192 \u2225normed_group_hom.equalizer.map \u03c6 \u03c8 hf hg\u2225 \u2264 C"}
{"type": "\u2200 {R : Type u_1} [_inst_1 : normed_ring R] [_inst_2 : complete_space R] (x : units R) (t : R) (h : \u2225t\u2225 < \u2225\u2191x\u207b\u00b9\u2225\u207b\u00b9), \u2191(x.add t h) = \u2191x + t"}
{"type": "\u2200 {c : cardinal}, cardinal.omega \u2264 c \u2194 \u2203 (o : ordinal), c = cardinal.aleph o"}
{"type": "\u2200 {J : Type v} [_inst_1 : decidable_eq J] {C : Type u} [_inst_2 : category_theory.category C] [_inst_3 : category_theory.limits.has_zero_morphisms C] (f : J \u2192 C) [_inst_4 : category_theory.limits.has_biproduct f] {j j' : J}, j \u2260 j' \u2192 \u2200 {X' : C} (f' : f j' \u27f6 X'), category_theory.limits.biproduct.\u03b9 f j \u226b category_theory.limits.biproduct.\u03c0 f j' \u226b f' = 0 \u226b f'"}
{"type": "\u2200 {\u03b9 : Type u_1} {\u03b1 : Type u_3} {\u03b2 : Type u_4} [_inst_1 : preorder \u03b1] [_inst_2 : preorder \u03b2] {f : \u03b9 \u2192 \u03b1} {g : \u03b9 \u2192 \u03b2}, antivary f g \u2192 antivary (\u21d1order_dual.to_dual \u2218 f) (\u21d1order_dual.to_dual \u2218 g)"}
{"type": "\u2200 {\u03b1 : Type u_1} [_inst_1 : primcodable \u03b1], transitive one_one_reducible"}
{"type": "\u2200 (x : \u2102), complex.sin (x - 2 * \u2191real.pi) = complex.sin x"}
{"type": "\u2200 {\u03b1 : Type u_1} [_inst_1 : partial_order \u03b1] [_inst_2 : succ_order \u03b1] [_inst_3 : pred_order \u03b1] {a b : \u03b1}, a < b \u2192 pred_order.pred (succ_order.succ a) = a"}
{"type": "\u2200 {R : Type u_1} [_inst_1 : comm_semiring R] (M : Type u_4) {N : Type u_5} {P : Type u_6} [_inst_4 : add_comm_monoid M] [_inst_5 : add_comm_monoid N] [_inst_6 : add_comm_monoid P] [_inst_9 : module R M] [_inst_10 : module R N] [_inst_11 : module R P] (f : N \u2192\u2097[R] P) (m : M) (n : N), \u21d1(linear_map.ltensor M f) (m \u2297\u209c[R] n) = m \u2297\u209c[R] \u21d1f n"}
{"type": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : has_le \u03b1] [_inst_2 : has_le \u03b2] (e : \u03b1 \u2243o \u03b2) {x y : \u03b1}, \u21d1e x = \u21d1e y \u2194 x = y"}
{"type": "\u2200 {\u03b1 : Type u_1} (a : \u03b1) (l : list \u03b1), l <+: l.concat a"}
{"type": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_3} [_inst_1 : measurable_space \u03b1] [_inst_3 : measurable_space \u03b2] {\u03bd : measure_theory.measure \u03b2} [_inst_8 : measure_theory.sigma_finite \u03bd] {f : \u03b1 \u2192 \u03b2 \u2192 ennreal}, measurable (function.uncurry f) \u2192 measurable (\u03bb (x : \u03b1), \u222b\u207b (y : \u03b2), f x y \u2202\u03bd)"}
{"type": "\u2200 {C : Type u} [_inst_1 : category_theory.category C] {J : Type v} [_inst_3 : category_theory.category J] {K : Type v} [_inst_4 : category_theory.category K] [_inst_5 : category_theory.limits.has_limits_of_shape J C] (F : J \u2964 K \u2964 C) (X : K), (category_theory.limits.limit_iso_flip_comp_lim F).hom.app X = (category_theory.limits.limit_obj_iso_limit_comp_evaluation F X).hom"}
{"type": "\u2200 {\u03b1 : Type u_1} [_inst_1 : cancel_comm_monoid_with_zero \u03b1] [_inst_2 : normalization_monoid \u03b1], \u21d1normalize 1 = 1"}
{"type": "\u2200 {\u03b1 : Type u_1} (p q : \u03b1 \u2192 Prop) [_inst_1 : decidable_pred p] [_inst_2 : decidable_pred q] (s : finset \u03b1), finset.filter q (finset.filter p s) = finset.filter (\u03bb (a : \u03b1), p a \u2227 q a) s"}
{"type": "\u2200 {G : Type u} [_inst_1 : ordered_add_comm_group G] (a b c : G), (\u03bb (x : G), x - a) \u207b\u00b9' set.Icc b c = set.Icc (b + a) (c + a)"}
{"type": "\u2200 {k : Type u\u2081} {G : Type u\u2082} [_inst_1 : comm_semiring k] [_inst_2 : add_monoid G] {A : Type u\u2083} [_inst_3 : semiring A] [_inst_4 : algebra k A] \u2983\u03c6\u2081 \u03c6\u2082 : add_monoid_algebra k G \u2192\u2090[k] A\u2984, (\u2200 (x : G), \u21d1\u03c6\u2081 (finsupp.single x 1) = \u21d1\u03c6\u2082 (finsupp.single x 1)) \u2192 \u03c6\u2081 = \u03c6\u2082"}
{"type": "\u2200 {\u03b1 : Type u} {o' : Type u_3} [_inst_1 : semiring \u03b1] (v : fin 0 \u2192 \u03b1) (B : matrix (fin 0) o' \u03b1), matrix.vec_mul v B = 0"}
{"type": "\u2200 {R : Type u} {L\u2081 : Type v} [_inst_1 : comm_ring R] [_inst_2 : lie_ring L\u2081] [_inst_3 : lie_algebra R L\u2081], \u21d11 = id"}
{"type": "\u2200 {R : Type u_1} {R\u2082 : Type u_3} {M : Type u_9} {M\u2082 : Type u_12} {\u03b9 : Type u_17} [_inst_1 : semiring R] [_inst_2 : semiring R\u2082] [_inst_4 : add_comm_monoid M] [_inst_5 : add_comm_monoid M\u2082] {\u03c3\u2081\u2082 : R \u2192+* R\u2082} [_inst_8 : module R M] [_inst_9 : module R\u2082 M\u2082] {\u03b3 : Type u_20} [_inst_11 : has_zero \u03b3] (f : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) {t : \u03b9 \u2192\u2080 \u03b3} {g : \u03b9 \u2192 \u03b3 \u2192 M}, \u21d1f (t.sum g) = t.sum (\u03bb (i : \u03b9) (d : \u03b3), \u21d1f (g i d))"}
{"type": "\u2200 {\u03b1 : Type u_1} (l : list \u03b1), quotient.mk' l = \u2191l"}
{"type": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {x : E} {\ud835\udd38 : Type u_6} [_inst_10 : normed_ring \ud835\udd38] [_inst_12 : normed_algebra \ud835\udd5c \ud835\udd38] {a : E \u2192 \ud835\udd38}, differentiable_at \ud835\udd5c a x \u2192 \u2200 (b : \ud835\udd38), differentiable_at \ud835\udd5c (\u03bb (y : E), a y * b) x"}
{"type": "\u2200 {G : Type u_1} [_inst_1 : div_inv_monoid G] (a : G) (n : \u2115), a ^ \u2191n = a ^ n"}
{"type": "\u2200 {\u03b1 : Type u_1} {f : \u03b1 \u2192 \u03b1} {x : \u03b1} {n : \u2115}, n \u2260 0 \u2192 n < function.minimal_period f x \u2192 \u00acfunction.is_periodic_pt f n x"}
{"type": "\u2200 {R : Type u} [_inst_1 : ring R] (s : subring R) {x y : R}, x \u2208 s \u2192 y \u2208 s \u2192 x + y \u2208 s"}
{"type": "\u2200 {m n : \u2115}, (m + n).coprime n \u2194 m.coprime n"}
{"type": "\u2200 {\u03b1 : Type u_1} [_inst_1 : cancel_comm_monoid_with_zero \u03b1] {a b c d : \u03b1}, associated (a * b) (c * d) \u2192 associated b d \u2192 b \u2260 0 \u2192 associated a c"}
{"type": "\u2200 {\u03b1 : Type u} {n : \u2115} [_inst_1 : add_comm_monoid \u03b1] [_inst_2 : has_mul \u03b1] (v : fin n.succ \u2192 \u03b1) (x : \u03b1) (w : fin n \u2192 \u03b1), matrix.dot_product v (matrix.vec_cons x w) = matrix.vec_head v * x + matrix.dot_product (matrix.vec_tail v) w"}
{"type": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : semiring \u03b1] [_inst_2 : topological_space \u03b1] [_inst_3 : topological_ring \u03b1] {f : \u03b2 \u2192 \u03b1} {a\u2081 : \u03b1} (a\u2082 : \u03b1), has_sum f a\u2081 \u2192 has_sum (\u03bb (b : \u03b2), a\u2082 * f b) (a\u2082 * a\u2081)"}
{"type": "\u2200 {Q : Type u_1} [_inst_1 : quandle Q] {x : Q}, rack.inv_act x x = x"}
{"type": "nat.primrec nat.pred"}
{"type": "\u2200 {M : Type u_1} {N : Type u_2} [_inst_1 : div_inv_monoid M] [_inst_2 : div_inv_monoid N] (f : M \u2192* N), (\u2200 (x : M), \u21d1f x\u207b\u00b9 = (\u21d1f x)\u207b\u00b9) \u2192 \u2200 (a : M) (n : \u2124), \u21d1f (a ^ n) = \u21d1f a ^ n"}
{"type": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} (f : \u03b1 \u2192. \u03b2), f.dom = {x : \u03b1 | \u2203 (y : \u03b2), y \u2208 f x}"}
{"type": "\u2200 {\u03b1 : Type u} [_inst_1 : pseudo_emetric_space \u03b1] (x : \u03b1) {\u03b5 : ennreal}, 0 < \u03b5 \u2192 emetric.closed_ball x \u03b5 \u2208 nhds x"}
{"type": "\u2200 {k : Type u_1} {P\u2081 : Type u_2} {P\u2082 : Type u_3} {V\u2081 : Type u_6} {V\u2082 : Type u_7} [_inst_1 : ring k] [_inst_2 : add_comm_group V\u2081] [_inst_3 : module k V\u2081] [_inst_4 : add_torsor V\u2081 P\u2081] [_inst_5 : add_comm_group V\u2082] [_inst_6 : module k V\u2082] [_inst_7 : add_torsor V\u2082 P\u2082] (e : P\u2081 \u2243\u1d43[k] P\u2082), function.injective \u21d1e"}
{"type": "\u2200 {\u03b1 : Type u} {p q : \u03b1 \u2192 Prop} {f : filter \u03b1}, (\u2203\u1da0 (x : \u03b1) in f, p x) \u2192 (\u2200\u1da0 (x : \u03b1) in f, q x) \u2192 (\u2203\u1da0 (x : \u03b1) in f, p x \u2227 q x)"}
{"type": "\u2200 {\u03b1 : Type u} [_inst_1 : add_group \u03b1] [_inst_2 : has_le \u03b1] [_inst_3 : covariant_class \u03b1 \u03b1 has_add.add has_le.le] [_inst_4 : covariant_class \u03b1 \u03b1 (function.swap has_add.add) has_le.le] {a b : \u03b1}, -a \u2264 b \u2192 -b \u2264 a"}
{"type": "\u2200 {R : Type u} {a : R} [_inst_1 : semiring R] {p : polynomial R}, p.comp (\u21d1polynomial.C a) = \u21d1polynomial.C (polynomial.eval a p)"}
{"type": "\u2200 (n : pos_num), \u2191n = num.pos n"}
{"type": "\u2200 {S : Type u_2} {R : Type u} {M : Type v} {N : Type u_1} [_inst_1 : semiring S] [_inst_2 : add_comm_monoid R] [_inst_3 : add_comm_monoid M] [_inst_4 : add_comm_monoid N] [_inst_5 : module S R] [_inst_6 : module S M] [_inst_7 : module S N] \u2983f g : triv_sq_zero_ext R M \u2192\u2097[S] N\u2984, (\u2200 (r : R), \u21d1f (triv_sq_zero_ext.inl r) = \u21d1g (triv_sq_zero_ext.inl r)) \u2192 (\u2200 (m : M), \u21d1f (triv_sq_zero_ext.inr m) = \u21d1g (triv_sq_zero_ext.inr m)) \u2192 f = g"}
{"type": "\u2200 (x : ereal), x = \u22a5 \u2194 \u2200 (y : \u211d), x < \u2191y"}
{"type": "has_star.star = \u21d1star_ring_aut"}
{"type": "\u2200 {R : Type u_2} [_inst_1 : comm_semiring R] (\u03c6 : polynomial R) (n : \u2115), \u21d1(power_series.coeff R n) \u2191\u03c6 = \u03c6.coeff n"}
{"type": "\u2200 {a b : ordinal}, a < ordinal.omega \u2192 b < ordinal.omega \u2192 a + b < ordinal.omega"}
{"type": "\u2200 {\u03b1 : Type u_1} [_inst_1 : measurable_space \u03b1] {\u03bc : measure_theory.measure \u03b1} (f : \u03b1 \u2192\u2098[\u03bc] ennreal), \u222b\u207b (a : \u03b1), \u21d1f a \u2202\u03bc = f.lintegral"}
{"type": "\u2200 {R : Type u_1} [_inst_1 : comm_ring R] {c\u2081 c\u2082 : R} (a\u2081 a\u2082 a\u2083 a\u2084 b\u2081 b\u2082 b\u2083 b\u2084 : R), {re := a\u2081, im_i := a\u2082, im_j := a\u2083, im_k := a\u2084} * {re := b\u2081, im_i := b\u2082, im_j := b\u2083, im_k := b\u2084} = {re := a\u2081 * b\u2081 + c\u2081 * a\u2082 * b\u2082 + c\u2082 * a\u2083 * b\u2083 - c\u2081 * c\u2082 * a\u2084 * b\u2084, im_i := a\u2081 * b\u2082 + a\u2082 * b\u2081 - c\u2082 * a\u2083 * b\u2084 + c\u2082 * a\u2084 * b\u2083, im_j := a\u2081 * b\u2083 + c\u2081 * a\u2082 * b\u2084 + a\u2083 * b\u2081 - c\u2081 * a\u2084 * b\u2082, im_k := a\u2081 * b\u2084 + a\u2082 * b\u2083 - a\u2083 * b\u2082 + a\u2084 * b\u2081}"}
{"type": "\u2200 {R : Type u_1} [_inst_1 : comm_ring R] {c\u2081 c\u2082 : R} (a : quaternion_algebra R c\u2081 c\u2082), \u21d1quaternion_algebra.conj (\u21d1quaternion_algebra.conj a) = a"}
{"type": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : fintype \u03b1] [_inst_2 : decidable_eq \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : function.injective f) [_inst_3 : nonempty \u03b1], set.restrict (function.inv_fun f) (set.range f) = hf.inv_of_mem_range"}
{"type": "\u2200 {V : Type u_1} [_inst_1 : inner_product_space \u211d V] {x y : V}, inner_product_geometry.angle x y = real.pi \u2192 has_inner.inner x y = -(\u2225x\u2225 * \u2225y\u2225)"}
{"type": "\u2200 {\u03b1 : Type u} [_inst_1 : preorder \u03b1] {a b : \u03b1}, bdd_below (set.Icc a b)"}
{"type": "\u2200 {\u03b1 : Type u_1} (l : list \u03b1), list.sublists_len 0 l = [list.nil]"}
{"type": "\u2200 {\u03b9 : Type u_1} [_inst_1 : fintype \u03b9] (I : box_integral.box \u03b9), \u22a4.distortion = I.distortion"}
{"type": "\u2200 (R : Type u_1) {S : Type u_6} (M : Type u_9) [_inst_1 : semiring R] [_inst_2 : add_comm_monoid M] [_inst_3 : module R M] [_inst_4 : semiring S] [_inst_5 : module S M] [_inst_6 : smul_comm_class S R M] (s : S), \u21d1(module.to_module_End R M) s = distrib_mul_action.to_linear_map R M s"}
{"type": "\u2200 {\ud835\udd5c : Type u_6} [_inst_2 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_7} [_inst_3 : normed_group E] [_inst_4 : normed_space \ud835\udd5c E] {F : Type u_8} [_inst_5 : normed_group F] [_inst_6 : normed_space \ud835\udd5c F] [_inst_7 : measurable_space F] [_inst_8 : borel_space F], measurable (\u03bb (f : E \u2192L[\ud835\udd5c] F) (x : E), \u21d1f x)"}
{"type": "\u2200 {\u03b1 : Type u} [_inst_1 : linear_order \u03b1] {a\u2081 a\u2082 b\u2081 b\u2082 : \u03b1}, b\u2081 \u2264 b\u2082 \u2192 set.Ioo a\u2081 b\u2081 \u2229 set.Ioc a\u2082 b\u2082 = set.Ioo (linear_order.max a\u2081 a\u2082) b\u2081"}
{"type": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {\u03b3 : Type u_3} [_inst_1 : preorder \u03b1] [_inst_2 : preorder \u03b2] [_inst_3 : preorder \u03b3] (x : \u03b2 \u2192o \u03b3) (\u1fb0 : \u03b1 \u2192o \u03b2), \u21d1(\u21d1(\u21d1order_hom.comp\u2098 x) \u1fb0) = \u21d1x \u2218 \u21d1\u1fb0"}
{"type": "\u2200 {\u03b1 : Type u_1} {m : measurable_space \u03b1} {\u03bc \u03bd : measure_theory.measure \u03b1}, 0 \u2208 measure_theory.measure.lebesgue_decomposition.measurable_le \u03bc \u03bd"}
{"type": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : normed_linear_ordered_field \ud835\udd5c] (P : polynomial \ud835\udd5c), P \u2260 0 \u2192 (\u2200\u1da0 (x : \ud835\udd5c) in filter.at_top, \u00acP.is_root x)"}
{"type": "\u2200 {\u03b1 : Type u} [_inst_1 : boolean_algebra.core \u03b1] (a b : \u03b1), a \\ b = a \u2293 b\u1d9c"}
{"type": "\u2200 {\u03b1 : Type u_1} {l\u2081 l\u2082 : list \u03b1}, \u2191l\u2081 \u2286 \u2191l\u2082 \u2194 l\u2081 \u2286 l\u2082"}
{"type": "\u2200 {\u03b1 : Type u}, multiplicative.of_add.symm = multiplicative.to_add"}
{"type": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {F : Type u_3} [_inst_4 : normed_group F] [_inst_5 : normed_space \ud835\udd5c F] {f g : E \u2192 F} {x : E} {s : set E}, differentiable_within_at \ud835\udd5c f s x \u2192 differentiable_within_at \ud835\udd5c g s x \u2192 differentiable_within_at \ud835\udd5c (\u03bb (y : E), f y - g y) s x"}
{"type": "\u2200 {\u03b1 : Type u} {\u03b2 : Type u_1} (l : list (\u03b1 \u00d7 \u03b2)), l.unzip.fst = list.map prod.fst l"}
{"type": "\u2200 {\u03b1 : Type u_1} {r\u2081 r\u2082 : setoid \u03b1}, r\u2081 = r\u2082 \u2194 r\u2081.rel = r\u2082.rel"}
{"type": "\u2200 {C : Type u\u2081} [_inst_1 : category_theory.category C] {D : Type u\u2082} [_inst_2 : category_theory.category D] {L : C \u2964 D} {R : D \u2964 C} (h : L \u22a3 R) (X : C), (category_theory.comonad.comparison_forget h).inv.app X = \ud835\udfd9 (L.obj X)"}
{"type": "\u2200 {\u03b1 : Type u_1} [_inst_1 : linear_ordered_semiring \u03b1] [_inst_2 : floor_semiring \u03b1] {a : \u03b1} {n : \u2115}, n \u2260 0 \u2192 (\u230aa\u230b\u208a < n \u2194 a < \u2191n)"}
{"type": "\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [_inst_1 : topological_space \u03b1] [_inst_2 : topological_space \u03b2] {f : \u03b1 \u2192 \u03b2}, embedding f \u2192 \u2200 (a : \u03b1), filter.map f (nhds a) = nhds_within (f a) (set.range f)"}
{"type": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {F : Type u_3} [_inst_4 : normed_group F] [_inst_5 : normed_space \ud835\udd5c F] {s : set E} {f : E \u2192 F} {n : with_top \u2115}, times_cont_diff \ud835\udd5c n f \u2192 times_cont_diff_on \ud835\udd5c n f s"}
{"type": "\u2200 {\u03b1 : Type u_1} [_inst_1 : preorder \u03b1] {a : \u03b1}, \u22a5 = \u27e8a, _\u27e9"}
{"type": "\u2200 {n : Type u_1}, inhabited.default (equiv.perm n) = 1"}
{"type": "\u2200 {G : Type w} [_inst_1 : topological_space G] [_inst_2 : group G] [_inst_3 : topological_group G] (x y : G), filter.map (has_mul.mul x) (nhds y) = nhds (x * y)"}
{"type": "\u2200 {\u03b1 : Type u} {\u03b2 : Type v} [_inst_1 : decidable_eq \u03b2] (f : \u03b1 \u2192 \u03b2) (s : finset \u03b2) [_inst_2 : \u03a0 (x : \u03b2), decidable (x \u2208 set.range f)] (hf : set.inj_on f (f \u207b\u00b9' \u2191s)), finset.image f (s.preimage f hf) = finset.filter (\u03bb (x : \u03b2), x \u2208 set.range f) s"}
{"type": "\u2200 {\ud835\udd5c : Type u_1} [_inst_1 : nondiscrete_normed_field \ud835\udd5c] {E : Type u_2} [_inst_2 : normed_group E] [_inst_3 : normed_space \ud835\udd5c E] {F : Type u_3} [_inst_4 : normed_group F] [_inst_5 : normed_space \ud835\udd5c F] {f : E \u2192 F} {f' : E \u2192L[\ud835\udd5c] F} {s t : set E} {c : nnreal}, s \u2286 t \u2192 approximates_linear_on f f' t c \u2192 approximates_linear_on f f' s c"}
{"type": "real.pi / 2 \u2264 2"}
{"type": "\u2200 {J : Type v} [_inst_1 : category_theory.small_category J] (F : J \u2964 AddCommGroup) {j j' : J} (f : j \u27f6 j'), F.map f \u226b AddCommGroup.colimits.cocone_morphism F j' = AddCommGroup.colimits.cocone_morphism F j"}
{"type": "\u2200 {\u03b1 : Type u_1} [_inst_1 : decidable_eq \u03b1], list.nil.form_perm = 1"}
{"type": "\u2200 {\u03b1 : Type u_1} [_inst_1 : decidable_eq \u03b1] (l : list \u03b1) (x y : \u03b1), x \u2260 y \u2192 x \u2209 l \u2192 \u2200 (h : opt_param (x \u2208 y :: l ++ [x]) _), (y :: l ++ [x]).next x h = y"}
{"type": "\u2200 {p : \u2115} [_inst_1 : fact (nat.prime p)] (z : \u2124_[p]), \u2225z\u2225 \u2264 1"}
{"type": "\u2200 {\u03b1 : Type u_1} {\u03b9 : Sort u_4} {l : filter \u03b1} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 set \u03b1}, l.has_basis p s \u2192 l = filter.generate {U : set \u03b1 | \u2203 (i : \u03b9), p i \u2227 s i = U}"}
{"type": "\u2200 {\u03b1 : Type u_1} [_inst_1 : cancel_comm_monoid_with_zero \u03b1] [_inst_2 : normalized_gcd_monoid \u03b1] (m n k : \u03b1), gcd_monoid.lcm (gcd_monoid.lcm m n) k = gcd_monoid.lcm m (gcd_monoid.lcm n k)"}
{"type": "\u2200 {\u03b1 : Type u_1} [_inst_1 : semilattice_inf \u03b1] [_inst_2 : order_top \u03b1] {s : multiset \u03b1} {a : \u03b1}, a \u2208 s \u2192 s.inf \u2264 a"}
{"type": "\u2200 {\u03b1 : Type u_1} [_inst_1 : has_zero \u03b1] [_inst_2 : has_one \u03b1] [_inst_3 : has_add \u03b1] [_inst_4 : has_neg \u03b1] (n : \u2115), \u2191-[1+ n] = -(\u2191n + 1)"}
{"type": "\u2200 {\u03b9 : Type u_1} {\u03b1 : \u03b9 \u2192 Type u_3} [_inst_1 : fintype \u03b9] [_inst_3 : \u03a0 (i : \u03b9), measurable_space (\u03b1 i)] (\u03bc : \u03a0 (i : \u03b9), measure_theory.measure (\u03b1 i)) [_inst_4 : \u2200 (i : \u03b9), measure_theory.sigma_finite (\u03bc i)] (i : \u03b9) [_inst_5 : measure_theory.has_no_atoms (\u03bc i)] (x : \u03b1 i), \u21d1(measure_theory.measure.pi \u03bc) {f : \u03a0 (i : \u03b9), \u03b1 i | f i = x} = 0"}
